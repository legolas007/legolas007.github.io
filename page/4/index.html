<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.usherblog.site","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"بحث...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta name="description" content="Honor To The End">
<meta property="og:type" content="website">
<meta property="og:title" content="Usher_Ou&#39;s Blog">
<meta property="og:url" content="http://www.usherblog.site/page/4/index.html">
<meta property="og:site_name" content="Usher_Ou&#39;s Blog">
<meta property="og:description" content="Honor To The End">
<meta property="og:locale">
<meta property="article:author" content="Usher">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.usherblog.site/page/4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-Hans","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Usher_Ou's Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="تشغيل شريط التصفح" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Usher_Ou's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Never Say Never</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          المحتويات
        </li>
        <li class="sidebar-nav-overview">
          عام
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Usher</p>
  <div class="site-description" itemprop="description">Honor To The End</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">المقالات</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">التصنيفات</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">الوسوم</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.usherblog.site/2018/03/25/Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Usher">
      <meta itemprop="description" content="Honor To The End">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Usher_Ou's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/03/25/Redis%E9%9B%86%E7%BE%A4%E7%9A%84%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">Redis集群的伪分布式搭建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">نُشر في</span>
      

      <time title="أُنشأ: 2018-03-25 19:23:56 / عُدل: 20:29:20" itemprop="dateCreated datePublished" datetime="2018-03-25T19:23:56+08:00">2018-03-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">في</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis集群的伪分布式搭建"><a href="#Redis集群的伪分布式搭建" class="headerlink" title="Redis集群的伪分布式搭建"></a>Redis集群的伪分布式搭建</h1><blockquote>
<p>Redis集群中至少应该有三个节点。要保证集群的高可用，需要每个节点有一个备份机。<br>Redis集群至少需要6台服务器。<br>搭建伪分布式。可以使用一台CentOS虚拟机运行6个redis实例。需要修改redis的端口号7001-7006</p>
</blockquote>
<p>1、使用ruby脚本搭建集群。需要ruby的运行环境</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">安装ruby</span><br><span class="line"> um install ruby</span><br><span class="line"> um install rubygems</span><br></pre></td></tr></table></figure>


<p>2、安装ruby脚本运行使用的包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gem install redis-3.0.0.gem </span><br><span class="line"> uccessfully installed redis-3.0.0</span><br><span class="line">  gem installed</span><br><span class="line"> nstalling ri documentation for redis-3.0.0...</span><br><span class="line"> nstalling RDoc documentation for redis-3.0.0...</span><br><span class="line"> root@localhost ~]# </span><br><span class="line"> root@localhost ~]# cd redis-3.0.0/src</span><br><span class="line"> root@localhost src]# ll *.rb</span><br><span class="line"> rwxrwxr-x. 1 root root 48141 Apr  1  2015 redis-trib.rb</span><br></pre></td></tr></table></figure>

<p>3、修改redis.conf配置文件。配置文件中还需要把cluster-enabled yes前的注释去掉。</p>
<p><img src="http://ov1nop9io.bkt.clouddn.com/%E5%B1%B1%E4%B8%9C.png" alt="http://ov1nop9io.bkt.clouddn.com/%E5%B1%B1%E4%B8%9C.png"></p>
<p>4、创建集群实例文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis]# mkdir ../redis-cluster</span><br></pre></td></tr></table></figure>
<p>5、拷贝redis到集群文件夹创建实例redis01</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost local]# cp redis/bin redis-cluster/redis01 -r</span><br><span class="line">cp: omitting directory `redis/bin&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>6、删除appendonly.aof,dump.rdb</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis01]# rm -f appendonly.aof </span><br><span class="line">[root@localhost redis01]# rm -f dump.rdb </span><br></pre></td></tr></table></figure>
<p>7、更改端口为7001和cluster-enabled yes前的注释去掉</p>
<p><img src="http://ov1nop9io.bkt.clouddn.com/%E5%B1%B1%E4%B8%9C.png" alt="http://ov1nop9io.bkt.clouddn.com/%E5%B1%B1%E4%B8%9C.png"></p>
<p>8、复制redis01到集群文件夹创建其余实例,更改端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-cluster]# cp -r redis01/ redis02</span><br><span class="line">[root@localhost redis-cluster]# cp -r redis01/ redis03</span><br><span class="line">[root@localhost redis-cluster]# cp -r redis01/ redis04</span><br><span class="line">[root@localhost redis-cluster]# cp -r redis01/ redis05</span><br><span class="line">[root@localhost redis-cluster]# cp -r redis01/ redis06</span><br></pre></td></tr></table></figure>
<p>9、编写启动批处理shell文件start-all.sh</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cd redis01</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis02</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis03</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis04</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis05</span><br><span class="line">./redis-server redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd redis06</span><br><span class="line">./redis-server redis.conf</span><br></pre></td></tr></table></figure>
<p>10、赋予权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-cluster]# chmod u+x start-all.sh</span><br></pre></td></tr></table></figure>
<p>11、启动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-cluster]# ./start-all.sh </span><br><span class="line"></span><br><span class="line">[root@localhost redis-cluster]# ps aux|grep redis</span><br><span class="line">root      5893  0.0  0.3  33936  1696 ?        Ssl  21:04   0:07 ./redis-server *:6379    </span><br><span class="line">root      6385  0.0  0.3  33936  1960 ?        Ssl  23:36   0:00 ./redis-server *:7001 [cluster]</span><br><span class="line">root      6387  0.0  0.3  33936  1960 ?        Ssl  23:36   0:00 ./redis-server *:7002 [cluster]</span><br><span class="line">root      6391  0.1  0.3  33936  1960 ?        Ssl  23:36   0:00 ./redis-server *:7003 [cluster]</span><br><span class="line">root      6395  0.1  0.3  33936  1960 ?        Ssl  23:36   0:00 ./redis-server *:7004 [cluster]</span><br><span class="line">root      6401  0.0  0.3  33936  1960 ?        Ssl  23:36   0:00 ./redis-server *:7005 [cluster]</span><br><span class="line">root      6403  0.1  0.3  33936  1960 ?        Ssl  23:36   0:00 ./redis-server *:7006 [cluster]</span><br><span class="line">root      6411  0.0  0.1   4356   732 pts/1    S+   23:37   0:00 grep redis</span><br></pre></td></tr></table></figure>
<p>12、复制redis下的src目录中的redis-trib.rb到集群</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@localhost redis-3.0.0]# cd src</span><br><span class="line">[root@localhost src]# ll *.rb</span><br><span class="line">-rwxrwxr-x. 1 root root 48141 Apr  1  2015 redis-trib.rb</span><br><span class="line">[root@localhost src]# cp redis-trib.rb /usr/local/redis-cluster/</span><br></pre></td></tr></table></figure>

<p>13、使用ruby脚本搭建集群。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"> [root@localhost redis-cluster]# ./redis-trib.rb create --replicas 1 192.168.25.153:7001 192.168.25.153:7002 192.168.25.153:7003 192.168.25.153:7004 192.168.25.153:7005  192.168.25.153:7006</span><br><span class="line">&gt;&gt;&gt; Creating cluster</span><br><span class="line">   necting to node 192.168.25.153:7001: OK</span><br><span class="line">   necting to node 192.168.25.153:7002: OK</span><br><span class="line">   necting to node 192.168.25.153:7003: OK</span><br><span class="line">   necting to node 192.168.25.153:7004: OK</span><br><span class="line">   necting to node 192.168.25.153:7005: OK</span><br><span class="line">   necting to node 192.168.25.153:7006: OK</span><br><span class="line">&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...</span><br><span class="line">   ng 3 masters:</span><br><span class="line">192.168.25.153:7001</span><br><span class="line">192.168.25.153:7002</span><br><span class="line">192.168.25.153:7003</span><br><span class="line">   ing replica 192.168.25.153:7004 to 192.168.25.153:7001</span><br><span class="line">   ing replica 192.168.25.153:7005 to 192.168.25.153:7002</span><br><span class="line">   ing replica 192.168.25.153:7006 to 192.168.25.153:7003</span><br><span class="line">   2e48ae301e9c32b04a7d4d92e15e98e78de8c1f3 192.168.25.153:7001</span><br><span class="line">    lots:0-5460 (5461 slots) master</span><br><span class="line">   8cd93a9a943b4ef851af6a03edd699a6061ace01 192.168.25.153:7002</span><br><span class="line">    lots:5461-10922 (5462 slots) master</span><br><span class="line">   2935007902d83f20b1253d7f43dae32aab9744e6 192.168.25.153:7003</span><br><span class="line">    lots:10923-16383 (5461 slots) master</span><br><span class="line">   74f9d9706f848471583929fc8bbde3c8e99e211b 192.168.25.153:7004</span><br><span class="line">    eplicates 2e48ae301e9c32b04a7d4d92e15e98e78de8c1f3</span><br><span class="line">   42cc9e25ebb19dda92591364c1df4b3a518b795b 192.168.25.153:7005</span><br><span class="line">    eplicates 8cd93a9a943b4ef851af6a03edd699a6061ace01</span><br><span class="line">   8b1b11d509d29659c2831e7a9f6469c060dfcd39 192.168.25.153:7006</span><br><span class="line">    eplicates 2935007902d83f20b1253d7f43dae32aab9744e6</span><br><span class="line">    I set the above configuration? (type &#x27;yes&#x27; to accept): yes</span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">   ting for the cluster to join.....</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.25.153:7001)</span><br><span class="line">   2e48ae301e9c32b04a7d4d92e15e98e78de8c1f3 192.168.25.153:7001</span><br><span class="line">    lots:0-5460 (5461 slots) master</span><br><span class="line">   8cd93a9a943b4ef851af6a03edd699a6061ace01 192.168.25.153:7002</span><br><span class="line">    lots:5461-10922 (5462 slots) master</span><br><span class="line">   2935007902d83f20b1253d7f43dae32aab9744e6 192.168.25.153:7003</span><br><span class="line">    lots:10923-16383 (5461 slots) master</span><br><span class="line">   74f9d9706f848471583929fc8bbde3c8e99e211b 192.168.25.153:7004</span><br><span class="line">    lots: (0 slots) master</span><br><span class="line">    eplicates 2e48ae301e9c32b04a7d4d92e15e98e78de8c1f3</span><br><span class="line">   42cc9e25ebb19dda92591364c1df4b3a518b795b 192.168.25.153:7005</span><br><span class="line">    lots: (0 slots) master</span><br><span class="line">    eplicates 8cd93a9a943b4ef851af6a03edd699a6061ace01</span><br><span class="line">   8b1b11d509d29659c2831e7a9f6469c060dfcd39 192.168.25.153:7006</span><br><span class="line">    lots: (0 slots) master</span><br><span class="line">    eplicates 2935007902d83f20b1253d7f43dae32aab9744e6</span><br><span class="line">   ] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">   ] All 16384 slots covered.</span><br><span class="line">   ot@localhost redis-cluster]# </span><br><span class="line">   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>14、启动每个redis实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb create --replicas 1 192.168.25.153:7001 192.168.25.153:7002 192.168.25.153:7003 192.168.25.153:7004 192.168.25.153:7005 192.168.25.153:7006</span><br></pre></td></tr></table></figure>


<p>15、创建关闭集群的脚本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-cluster]# vim shutdow-all.sh</span><br><span class="line">edis01/redis-cli -p 7001 shutdown</span><br><span class="line">edis01/redis-cli -p 7002 shutdown</span><br><span class="line">edis01/redis-cli -p 7003 shutdown</span><br><span class="line">edis01/redis-cli -p 7004 shutdown</span><br><span class="line">edis01/redis-cli -p 7005 shutdown</span><br><span class="line">edis01/redis-cli -p 7006 shutdown</span><br><span class="line">root@localhost redis-cluster]# chmod u+x shutdow-all.sh </span><br></pre></td></tr></table></figure>

<p>16、    集群的使用方法,Redis-cli连接集群</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-cluster]# redis01/redis-cli -p 7002 -c</span><br></pre></td></tr></table></figure>

<blockquote>
<p>-c：代表连接的是redis集群</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.usherblog.site/2018/03/11/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Usher">
      <meta itemprop="description" content="Honor To The End">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Usher_Ou's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/03/11/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">Android四大组件学习笔记总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">نُشر في</span>
      

      <time title="أُنشأ: 2018-03-11 19:23:56 / عُدل: 22:42:12" itemprop="dateCreated datePublished" datetime="2018-03-11T19:23:56+08:00">2018-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">في</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Android四大组件学习笔记总结"><a href="#Android四大组件学习笔记总结" class="headerlink" title="Android四大组件学习笔记总结"></a>Android四大组件学习笔记总结</h1><p>Android四大组件分别是Activity，Service，ContentProvider，BroadcastReceiver。</p>
<h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>Android中，activity是所有程序的根本，所有程序的流程都运行在activity之中，activity可以算是开发者遇到的最频繁，也是android当中最基本的模块之一。在android的程序中，activity一般代表手机屏幕的一屏。如果把手机比作一个浏览器，那么activity就相当于一个网页。在activity当中可以添加一些Button、Checkbox等控件，可以看到activity概念和网页的概念相当类似。</p>
</blockquote>
<blockquote>
<p>一般一个android应用是由多个activity组成的，这多个activity之间可以进行相互跳转。例如，按下一个Button按钮后，可能会跳转到其他的activity，与网页跳转稍微有点不一样的是，activity之间的跳转有可能返回值。例如，从activity A跳转到activity B，那么当activity B运行结束时，有可能会给activity A一个返回值。这样做在很多时候是相当方便的。</p>
</blockquote>
<blockquote>
<p>当打开一个新的屏幕时，之前一个屏幕会被置为暂停状态，并且压入历史堆栈中。用户可以通过回退操作返回到以前打开过的屏幕。可以选择性的一处一些没有必要保留的屏幕，因为Android会把每个应用的开始到当前的每个屏幕保存在堆栈中。</p>
</blockquote>
<h3 id="生命周期及方法"><a href="#生命周期及方法" class="headerlink" title="生命周期及方法"></a>生命周期及方法</h3><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p><img src="http://ov1nop9io.bkt.clouddn.com/%E6%9C%AA%E5%91%BD%E5%90%8D%E5%9B%BE%E7%89%87.png" alt="enter image description here"></p>
<blockquote>
<p>一个activity的生命周期就像我们一样，从出生到童年，青年，中年，老年<br>    最后入土.Activity从创建到销毁有多种状态，从一种状态到另一种状态时会激发相应的回调方法，从onCreate(),<br>    onStart(),onPause(),onResume(),onstop(),onDestroy(),到onRestart()等方法.</p>
</blockquote>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><blockquote>
</blockquote>
<p>onCreat()方法，谷歌官方的解释是：当这个界面第一次创建的时候执行这个方法，当然<br>   一般情况下，在一个应用中这个方法只会执行一次，（横竖屏切换），既然这个方法最先执行，那我们就可以在<br>   这个方法体里面做一些初始化的操作，如 初始化view(setCountentView(view)),寻找控件 findViewById(id)，<br>   初始化一些数据等等。<br>        执行完oncreate方法界面展示后，即当Activity变成可见的时候，开始执行onStart()方法 ，这个方法和<br>  onStop()方法对应。这个方法的用处不怎么大。<br>        onResume()方法，当一个界面可以和用户交互，获取到焦点的的时候，执行这个方法，什么是和用户交互？<br>  比如说，你点击屏幕上的按钮，图片等等，activity会给出不同的反应。<br>        onPause()方法和onResume()方法对应，即activity不能和用户交互的，activity失去焦点，界面上的view<br>  不能被点击的时候执行。<br>       onStop()方法，当activity不可见的时候，执行这个方法，如从一个activity跳转到另一个activity时，跳转<br>  前的activity被跳转后的activity遮挡，就会执行onStop()这个方法<br>       onRestart()方法，从第一个activity跳转到第二个activity，再返回第一个 activity时，就会执行这个方法<br>  界面重新变得可见就会执行这个方法。<br>       onDestroy()方法，当一个activity销毁的时候调用这个方法，与onCreate()对应。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><blockquote>
</blockquote>
<p>  （1）一个Activity通常就是一个单独的屏幕（窗口）。<br>（2）Activity之间通过Intent进行通信。<br>（3）android应用中每一个Activity都必须要在AndroidManifest.xml配置文件中声明，否则系统将不识别也不执行该Activity。</p>
<h3 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h3><blockquote>
<p>(1)标准 standard，大部分应用都是这个标准启动模式。 </p>
</blockquote>
<blockquote>
<p> (2)singleTop 单一顶部模式   当我们把Activity配置成 singleTop启动模式的时候 ,当我们在开启这个Activity的时候 就会检查当前任务栈的栈顶是否有这个实例存在,如果存在就不会创建新的实例,而是直接复用这个实例   </p>
</blockquote>
<blockquote>
<p> (3)singleTask 当我们 把Activity设置成singleTask启动模式 会检查当前任务栈 是否有实例开启 ,如果有实例开启,就会直接复用这个实例 ,并且会把这个实例上面其他的Activity 也清空,当前任务栈只有一个实例存在   </p>
</blockquote>
<blockquote>
<p>(4)singleinstance :如果把一个Activity配置这种启动模式,系统会为这个Activity单独创建一个任务栈,这个Activity在自己的任务栈里面存在 </p>
</blockquote>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>Service是android系统中的一种组件，跟activity的级别差不多，但是他不能自己运行，只能后台运行，并且可以和其他组件进行交互。Service是没有界面长生命周期的代码。Service是一种程序，可以运行很长时间的，但是却没有用户界面。这么说有点枯燥，来看个例子。打开一个音乐播放器的程序，这时如果想上网，那么打开Android浏览器，这时虽然已经进入浏览器这个程序，但是歌曲播放并没有停止，而是在后台继续一首接一首的播放，其实这个播放就是由播放音乐的Service进行控制。当然这个播放音乐的Service也可以停止。例如，当播放列表里的歌曲都结束，或用户按下了停止音乐播放的快捷键等。Service可以在很多场合的应用中使用，如播放多媒体时用户启动了其他Activity，这时程序要在后台继续播放，比如检测SD卡上文件的变化，或在后台记录地理信息位置的改变等，而服务却藏在后台。</p>
</blockquote>
<h3 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="http://ov1nop9io.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20180311223711.png" alt="enter image description here"></p>
<h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><blockquote>
<p>（1）service用于在后台完成用户指定的操作。service分为两种：</p>
</blockquote>
<blockquote>
<p>（a）started（启动）：当应用程序组件（如activity）调用startService()方法启动服务时，服务处于started状态。</p>
</blockquote>
<blockquote>
<p>（b）bound（绑定）：当应用程序组件调用bindService()方法绑定到服务时，服务处于bound状态。</p>
</blockquote>
<h3 id="开启Service两种方式："><a href="#开启Service两种方式：" class="headerlink" title="开启Service两种方式："></a>开启Service两种方式：</h3><blockquote>
<p>（1）Context.starService（）：Service会经历onCreat  ——&gt;onStar(如果Service还没有运行，则Android先调用onCreat()，然后调用onStar（），所以一个Service的onStar方能会重复调用多次)；如果是调用者自己直接退出而没有调用StopService，服务会一直在后台运行。该服务的调用者再启动起来后可以通过stopService关闭服务。注意，多次调用Context.starService（）不会被嵌套（即使会有相应的onStar（）方法被调用），所以无论同一个服务被启动多少次，一旦调用Context.stopService（）或者StopSelf（），都会被停止。</p>
</blockquote>
<blockquote>
<p>说明：传递给starService（）的Intent对象会传递给onStar()方法。调用顺序为onCreat——onStar（可调用多次）——onDestroy.</p>
</blockquote>
<blockquote>
<p>（2）Context.bindService()：服务会经历onCreate（）——onBind（），onBind将返回给客户端一个IBind接口实例，IBind允许客户端回调服务的方法，比如得到服务运行的状态或其他操作。这个时候把调用者（Context，如Activity）会和服务绑定在一起，Context退出了，服务就会调用onUnbind——onDestroy相应退出，所谓绑定在一起就是“共存亡”了。</p>
</blockquote>
<blockquote>
<p>(3)我们在开发的过程中还必须注意Service实例只会有一个，也就是说如果当前要启动的Service已经存在了那么就不会再次创建该Service当然也不会调用onCreate()方法；</p>
</blockquote>
<blockquote>
<p>  一个Service可以被多个客户进行绑定，只有所有绑定对象都执行了onBind()方法后该Service才会销毁，不过如果有一个用户执行了onStart()方法，那么这个时候如果其他所有的bind客户都执行了unBind()。 该Service也不会销毁,很多应用都是用startService和bindService混合开启服务,比如音乐播放器，第三方支付等这时我们可能会有一个疑问：既然有StartService开启服务，为什么还要用bindService开启服务？目的就是为了使用bindserivce调用服务里面的方法这时就出现了解决进程间的通信问题：IPC.</p>
</blockquote>
<h2 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>内容提供者（Content Provider）是Android提供的第三方应用数据的访问方案。</p>
</blockquote>
<blockquote>
<p>在Android中，对数据的保护是很严密的，除了放在SD卡中的数据，一个应用所持有的数据库、文件等内容，都是不允许其他直接访问的。Android当然不会真的把每一个应用都做成一座“孤岛”，它为所有应用都准备可一扇窗，这就是Content Provider。应用想对外提供的数据，可以通过派生Content Provider类，封装成一枚Content Provider。每个Content Provider都用一个uri作为独立的标识，形如：content://com.xxxxx。所有应用看着像REST的样子，但实际上它比REST更为灵活。和REST类似，uri也可以有两种类型，一种是带id的；另一种是列表的，但实现者不需要按照这个模式来做，给id的uri也可以返回列表类型的数据。</p>
</blockquote>
<h3 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3><blockquote>
<p>（1）android平台提供了Content Provider使一个应用程序的指定数据集提供给其他应用程序。其他应用可以通过ContentResolver类从该内容提供者中获取或存入数据。</p>
</blockquote>
<blockquote>
<p>（2）只有需要在多个应用程序间共享数据是才需要内容提供者。例如，通讯录数据被多个应用程序使用，且必须存储在一个内容提供者中。它的好处是统一数据访问方式。</p>
</blockquote>
<blockquote>
<p>（3）ContentProvider实现数据共享。ContentProvider用于保存和获取数据，并使其对所有应用程序可见。这是不同应用程序间共享数据的唯一方式，因为android没有提供所有应用共同访问的公共存储区。</p>
</blockquote>
<blockquote>
<p>（4）开发人员不会直接使用ContentProvider类的对象，大多数是通过ContentResolver对象实现对ContentProvider的操作。</p>
</blockquote>
<blockquote>
<p>（5）ContentProvider使用URI来唯一标识其数据集，这里的URI以content://作为前缀，表示该数据由ContentProvider来管理。</p>
</blockquote>
<h2 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>在Android中，广播是一种广泛运用的在应用程序之间传输信息的机制。而广播接收器是对发送出来的广播进行过滤接受并响应的一类组件。可以使用广播接收器来让应用对一个外部时间做出响应。<br>（1）你的应用可以使用它对外部事件进行过滤，只对感兴趣的外部事件(如当电话呼入时，或者数据网络可用时)进行接收并做出响应。广播接收器没有用户界面。然而，它们可以启动一个activity或serice来响应它们收到的信息，或者用NotificationManager来通知用户。通知可以用很多种方式来吸引用户的注意力，例如闪动背灯、震动、播放声音等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息广播接收器不NotificationManager来通知用户这些事情发生了。<br>（2）广播接收者的注册有两种方法，分别是程序动态注册和AndroidManifest文件中进行静态注册,即广播接收器既可以在AndroidManifest.xml中注册，也可以在运行时的代码中使用Context.registerReceive（）进行注册。<br>（3）动态注册广播接收器特点是当用来注册的Activity关掉后，广播也就失效了。静态注册无需担忧广播接收器是否被关闭，只要设备是开启状态，广播接收器也是打开着的。也就是说哪怕app本身未启动，该app订阅的广播在触发时也会对它起作用只要是注册了，当事件来临时，即使程序没有启动，系统也在需要的时候启动程序。各种应用还可以通过使用Context.sendBroadcast（）将它们自己的Intent广播给其他应用程序。</p>
</blockquote>
<h3 id="有序广播和无序广播"><a href="#有序广播和无序广播" class="headerlink" title="有序广播和无序广播"></a>有序广播和无序广播</h3><blockquote>
<p>有序广播和无序广播</p>
</blockquote>
<pre><code>  内部通信实现机制：通过Android系统的Binder机制实现通信的

 无序广播：sendBroadcast()方法发送的广播为无序广播，无序广播逻辑上可以被任何广播接受者接收到，优点是效率高。缺点是一个接收者不能将处理结果传递给下一个接收者，传递的数据在传输过程中不能被修改，并无法终止广播的传播。

  有序广播：sendOrderedBroadcast()方法发送的广播为有序广播，有序广播依次传播，列如有三个广播接收者A,B,C, 优先级是A&gt;B&gt;C，
   此时发送一条广播，那这个消息先传给A，再传给B， 最后传给C，每个接收者都有权终止广播，比如B终止广播，C就无法接受到，
   此外A接收到广播后可以对结果对象进行操作，当广播传给B时，B可以从结果对象中获取A存入的数据。在通过context.sendOrderedBroadcast(intent, receiverPermission, resultReceiver, scheduler,initialCode, initialData, initialExtras);时我们可以指定resultReceiver广播接收者，这个接收者我们可以认为是最终接收者，通常情况下如果比他优先级更高的接收者如果没有终止广播，那么他的onReceive方法会被执行两次，第一次是正常的按照优先级顺序执行，第二次是作为最终接收者接收，如果比他优先级高的接收者终止了广播，那么他依然能接收到广播。

 在我们的项目中经常使用广播接收者接收系统通知，比如开机启动，sd卡挂载，低电量，外拨电话，锁屏等等，

 如果我们做的是播放器，那么监听到用户锁屏后我们应该将我们的播放器暂停等。
</code></pre>
<blockquote>
<p>需要注意的地方：</p>
</blockquote>
<pre><code>1.BroadcastReceiver的生命周期是非常短暂的，在接收广播的时候创建，onReceiver()方法结束之后销毁。               2. 广播接收者中不要做一些耗时的工作，否则会弹出Application No Response（应用无响应anr）错误对话框,，一般耗时的较长的操作最好放在服务中完成。



    3.最好也不要在广播接收者中创建子线程做耗时操作,因为广播接收者被销毁后进程就成为空进程，而空进程很容易被系统杀掉。     



   Android中引入广播机制的用意 ：

    1.程序间互通消息(例如在自己的应用程序内监听系统的来电)

    2.效率上(参考UDP的广播协议在局域网的方便性)
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>（1）4大组件的注册</p>
</blockquote>
<p> 4大基本组件都需要注册才能使用，每个Activity、service、Content Provider都需要在AndroidManifest文件中进行配置。AndroidManifest文件中未进行声明的activity、服务以及内容提供者将不为系统所见，从而也就不可用。而broadcast receiver广播接收者的注册分静态注册（在AndroidManifest文件中进行配置）和通过代码动态创建并以调用Context.registerReceiver()的方式注册至系统。需要注意的是在AndroidManifest文件中进行配置的广播接收者会随系统的启动而一直处于活跃状态，只要接收到感兴趣的广播就会触发（即使程序未运行）。</p>
<blockquote>
<p>（2）4大组件的激活</p>
</blockquote>
<p>内容提供者的激活：当接收到ContentResolver发出的请求后，内容提供者被激活。而其它三种组件activity、服务和广播接收器被一种叫做intent的异步消息所激活。</p>
<blockquote>
<p>（3）4大组件的关闭</p>
</blockquote>
<p>内容提供者仅在响应ContentResolver提出请求的时候激活。而一个广播接收器仅在响应广播信息的时候激活。所以，没有必要去显式的关闭这些组件。Activity关闭：可以通过调用它的finish()方法来关闭一个activity。服务关闭：对于通过startService()方法启动的服务要调用Context.stopService()方法关闭服务，使用bindService()方法启动的服务要调用Contex.unbindService()方法关闭服务。</p>
<blockquote>
<p>（4）android中的任务（activity栈）</p>
</blockquote>
<p>（a）任务其实就是activity的栈，它由一个或多个Activity组成，共同完成一个完整的用户体验。栈底的是启动整个任务的Activity，栈顶的是当前运行的用户可以交互的Activity，当一个activity启动另外一个的时候，新的activity就被压入栈，并成为当前运行的activity。而前一个activity仍保持在栈之中。当用户按下BACK键的时候，当前activity出栈，而前一个恢复为当前运行的activity。栈中保存的其实是对象，栈中的Activity永远不会重排，只会压入或弹出。</p>
<p>（b）任务中的所有activity是作为一个整体进行移动的。整个的任务（即activity栈）可以移到前台，或退至后台。</p>
<p>（c）Android系统是一个多任务(Multi-Task)的操作系统，可以在用手机听音乐的同时，也执行其他多个程序。每多执行一个应用程序，就会多耗费一些系统内存，当同时执行的程序过多，或是关闭的程序没有正确释放掉内存，系统就会觉得越来越慢，甚至不稳定。为了解决这个问题，Android引入了一个新的机制，即生命周期(Life Cycle)。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.usherblog.site/2018/03/11/Spring%20AOP%E4%B8%8EIoC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Usher">
      <meta itemprop="description" content="Honor To The End">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Usher_Ou's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/03/11/Spring%20AOP%E4%B8%8EIoC/" class="post-title-link" itemprop="url">Spring AOP与IoC</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">نُشر في</span>

      <time title="أُنشأ: 2018-03-11 19:23:56" itemprop="dateCreated datePublished" datetime="2018-03-11T19:23:56+08:00">2018-03-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">عُدل في</span>
        <time title="عُدل: 2018-03-23 19:57:50" itemprop="dateModified" datetime="2018-03-23T19:57:50+08:00">2018-03-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">في</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-AOP与IoC"><a href="#Spring-AOP与IoC" class="headerlink" title="Spring AOP与IoC"></a>Spring AOP与IoC</h1><h2 id="Spring框架简介"><a href="#Spring框架简介" class="headerlink" title="Spring框架简介"></a>Spring框架简介</h2><p>Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。<strong>简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。</strong></p>
<p>​        　spring的基本框架主要包含六大模块：DAO、ORM、AOP、JEE、WEB、CORE</p>
<p><img src="https://images2015.cnblogs.com/blog/644566/201609/644566-20160903123450558-100405609.png" alt="img"></p>
<p><strong>Spring DAO</strong>：Spring提供了对JDBC的操作支持：JdbcTemplate模板工具类 。</p>
<p><strong>Spring ORM</strong>：Spring可以与ORM框架整合。例如Spring整合Hibernate框架，其中Spring还提供HibernateDaoSupport工具类，简化了Hibernate的操作 。</p>
<p><strong>Spring WEB</strong>：Spring提供了对Struts、Springmvc的支持，支持WEB开发。与此同时Spring自身也提供了基于MVC的解决方案 。</p>
<p><strong>Spring  AOP</strong>：Spring提供面向切面的编程，可以给某一层提供事务管理，例如在Service层添加事物控制 。</p>
<p><strong>Spring   JEE</strong>：J2EE开发规范的支持，例如EJB 。</p>
<p><strong>Spring Core</strong>：提供IOC容器对象的创建和处理依赖对象关系 。</p>
<h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>IOC（Inversion of Control），就是具有依赖注入功能的容器，是可以创建对象的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。通常new一个实例，控制权由程序员控制，即“控制反转”,是指new实例工作不由程序员来做而是交给Spring容器来做。。在Spring中BeanFactory是IOC容器的实际代表者。另外一种说法叫DI（Dependency Injection），即依赖注入。在容器创建对象后，处理对象的依赖关系。它并不是一种技术实现，而是一种设计思想。在任何一个有实际开发意义的程序项目中，我们会使用很多类来描述它们特有的功能，并且通过类与类之间的相互协作来完成特定的业务逻辑。这个时候，每个类都需要负责管理与自己有交互的类的引用和依赖，代码将会变的异常难以维护和极度的高耦合。而IOC的出现正是用来解决这个问题，我们通过IOC将这些相互依赖对象的创建、协调工作交给Spring容器去处理，每个对象只需要关注其自身的业务逻辑关系就可以了。在这样的角度上来看，获得依赖的对象的方式，进行了反转，变成了由spring容器控制对象如何获取外部资源（包括其他对象和文件资料等等）。</p>
</blockquote>
<h3 id="IoC思想"><a href="#IoC思想" class="headerlink" title="IoC思想"></a>IoC思想</h3><blockquote>
<p> 在传统实现中,我们都是通过应用程序自己来管理依赖的创建,例如下代码.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 由Person自己管理Food类的创建</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Food food = <span class="keyword">new</span> Chicken();</span><br><span class="line">		System.out.println(<span class="string">&quot;I am eating &quot;</span> + food.getName() + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>而<code>IoC</code>则是通过一个<strong>第三方容器来管理并维护这些被依赖对象,应用程序只需要接收并使用IoC容器注入的对象而不需要关注其他事情</strong>.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	private Food food;</span><br><span class="line">	<span class="comment">// 通过set注入</span></span><br><span class="line">	public <span class="keyword">void</span> <span class="function"><span class="title">setFood</span>(<span class="params">Food food</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.food = food;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Person不需要关注Food,只管使用即可</span></span><br><span class="line">	public <span class="keyword">void</span> <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;I am eating &quot;</span> + <span class="built_in">this</span>.food.getName() + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>控制反转其实就是对象控制权的转移,<strong>应用程序将对象的控制权转移给了第三方容器并通过它来管理这些被依赖对象,完成了应用程序与被依赖对象的解耦.</strong></p>
</blockquote>
<h3 id="注入方式"><a href="#注入方式" class="headerlink" title="注入方式"></a>注入方式</h3><blockquote>
<ul>
<li>set注入方式:实现特定属性的public set()方法,来让<code>IoC</code>容器调用注入所依赖类型的对象.</li>
<li><strong>静态工厂注入方式</strong>: 实现特定接口以供<code>IoC</code>容器注入所依赖类型的对象.</li>
<li><strong>构造方法注入方式</strong> : 实现特定参数的构造函数,在创建对象时来让<code>IoC</code>容器注入所依赖类型的对象.</li>
<li><strong>基于注解的方式</strong>: 通过<code>Java</code>的注解机制来让<code>IoC</code>容器注入所依赖类型的对象,例如<code>Spring</code>框架中的<code>@Autowired</code>.</li>
</ul>
</blockquote>
<h4 id="set注入方式"><a href="#set注入方式" class="headerlink" title="set注入方式"></a>set注入方式</h4><blockquote>
<p>控制层</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> OrderServiceImp orderService;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderService</span><span class="params">(OrderServiceImp orderService)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.orderService = orderService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring配置XML文件：其中配置声明OrderAction类存在属性orderService。程式运行时候，会将已经实例化的orderService对象调用setOrderService方式注入。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;orderAction&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.pec.action.OrderAction&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;orderService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;orderService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;orderService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.pec.service.imp.OrderServiceImp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="构造器注入方式"><a href="#构造器注入方式" class="headerlink" title="构造器注入方式"></a>构造器注入方式</h4><blockquote>
<p>控制层</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> OrderServiceImp orderService;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OrderAction</span><span class="params">(OrderServiceImp orderService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderService = orderService;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>XML</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;orderAction&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.pec.action.OrderAction&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;orderService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;orderService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.pec.service.imp.OrderServiceImp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="基于注解的方式-推荐"><a href="#基于注解的方式-推荐" class="headerlink" title="基于注解的方式(推荐)"></a>基于注解的方式(推荐)</h4><blockquote>
<p>控制层</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>   <span class="comment">//@Resource</span></span><br><span class="line"><span class="keyword">private</span> OrderServiceImp orderService;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>服务层</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;orderService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImp</span> <span class="keyword">implements</span> <span class="title">IOrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaOrderMDaoImp javaOrderMDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaOrderDDaoImp javaOrderDDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;JavaOrderMList&gt; <span class="title">findOrderM</span><span class="params">(OrderSearch search)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> javaOrderMDao.findJavaOrderM(search);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;JavaOrderDList&gt; <span class="title">findOrderD</span><span class="params">(OrderSearch search)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> javaOrderDDao.findJavaOrderD(search);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DAO</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;javaOrderMDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaOrderMDaoImp</span> <span class="keyword">extends</span> <span class="title">BaseHibernateDAO</span>&lt;<span class="title">JavaOrderM</span>, <span class="title">Serializable</span>&gt; <span class="keyword">implements</span> <span class="title">IJavaOrderMDao</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository(&quot;javaOrderDDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaOrderDDaoImp</span> <span class="title">extendsBaseHibernateDAO</span>&lt;<span class="title">JavaOrderD</span>, <span class="title">Serializable</span>&gt; <span class="keyword">implements</span> <span class="title">IJavaOrderDDao</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>⑴ 持久层DAO层注解Repository中规定了名称，在Service层中声明名称必须一致。</p>
<p>⑵ 服务层Service层注解Service中规定了名称，在控制层中声明的名称必须一致。</p>
</blockquote>
<blockquote>
<p>⑶ 注解方式注入依赖注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component         把对象加入ioc容器，对象引用名称是类名，第一个字母小写</span><br><span class="line">@Component(“name”) 把指定名称的对象，加入ioc容器</span><br><span class="line">@Repository        主要用于标识加入容器的对象是一个持久层的组件(类)</span><br><span class="line">@Service           主要用于标识加入容器的对象是一个业务逻辑层的组件</span><br><span class="line">@Controller        主要用于标识加入容器的对象是一个控制层的组件</span><br><span class="line">@Resource          注入属性(DI), 会从容器中找对象注入到@Resource修饰的对象上</span><br><span class="line">@Autowired         注入属性(DI), 会从容器中找对象注入到@Autowired修饰的对象上</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>⑷ 注解可以简化配置，提升开发效率，但是也不利于后期维护。</p>
</blockquote>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>AOP（Aspect-OrientedProgramming），即“面向切面编程”。<strong>它是一种在运行时,动态地将代码切入到类的指定方法、指定位置上的编程思想.<strong>用于</strong>切入到指定类指定方法的代码片段叫做切面</strong>,而<strong>切入到哪些类中的哪些方法叫做切入点.</strong> 往往被定义为促使软件系统实现关注点的分离的技术。系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这些组件还经常承担着额外的职责。例如日志、事务管理和安全这样的核心服务经常融入到自身具有核心业务逻辑的组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。</p>
</blockquote>
<h3 id="AOP名词解释"><a href="#AOP名词解释" class="headerlink" title="AOP名词解释"></a>AOP名词解释</h3><blockquote>
<p><strong>切面（Aspect）</strong>：其实就是共有功能的实现。如日志切面、权限切面、事务切面等。在实际应用中通常是一个存放共有功能实现的普通Java类，之所以能被AOP容器识别成切面，是在配置中指定的。</p>
<p><strong>通知（Advice）</strong>：是切面的具体实现。以目标方法为参照点，根据放置的地方不同，可分为前置通知（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）与环绕通知（Around）5种。在实际应用中通常是切面类中的一个方法，具体属于哪类通知，同样是在配置中指定的。</p>
<p><strong>连接点（Joinpoint）</strong>：就是程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出或字段修改等，但Spring只支持方法级的连接点。</p>
<p><strong>切入点（Pointcut）</strong>：用于定义通知应该切入到哪些连接点上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的正则表达式来定义的。</p>
<p><strong>目标对象（Target）</strong>：就是那些即将切入切面的对象，也就是那些被通知的对象。这些对象中已经只剩下干干净净的核心业务逻辑代码了，所有的共有功能代码等待AOP容器的切入。</p>
<p><strong>代理对象（Proxy）</strong>：将通知应用到目标对象之后被动态创建的对象。可以简单地理解为，代理对象的功能等于目标对象的核心业务逻辑功能加上共有功能。代理对象对于使用者而言是透明的，是程序运行过程中的产物。</p>
<p><strong>织入（Weaving）</strong>：将切面应用到目标对象从而创建一个新的代理对象的过程。这个过程可以发生在编译期、类装载期及运行期，当然不同的发生点有着不同的前提条件。譬如发生在编译期的话，就要求有一个支持这种AOP实现的特殊编译器；发生在类装载期，就要求有一个支持AOP实现的特殊类装载器；只有发生在运行期，则可直接通过Java语言的反射机制与动态代理机制来动态实现。</p>
</blockquote>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><blockquote>
<p>在<code>OOP</code>中,我们使用封装的特性来将不同职责的代码抽象到不同的类中.但是在分散代码的同时,也增加了代码的重复性.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">something</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 业务逻辑...</span></span><br><span class="line">		recordLog();	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recordLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 记录日志...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">something</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 业务逻辑...</span></span><br><span class="line">		recordLog();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recordLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 记录日志...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="使用AOP分离外围业务代码"><a href="#使用AOP分离外围业务代码" class="headerlink" title="使用AOP分离外围业务代码"></a>使用AOP分离外围业务代码</h4><blockquote>
<p>我们使用<code>AspectJ</code>,它是一个<code>AOP</code>框架,扩展了Java语言,并定义了<code>AOP</code>语法(通过它实现的编译器).</p>
<p>使用<code>AspectJ</code>需要先安装并将lib中aspectjrt.jar添加进入classpath.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* AOP解决了代码的重复并将这些外围业务代码抽离到一个切面中,我们可以动态地将切面切入到切入点.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Say something...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Something something = <span class="keyword">new</span> Something();</span><br><span class="line">        something.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> aspect SomethingAspect &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切入点,切入到Something.say()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">pointcut <span class="title">recordLog</span><span class="params">()</span>:<span class="title">call</span><span class="params">(* com.sun.sylvanas.application.hello_aop.Something.say(..)</span>)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在方法执行后执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    after():recordLog() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[AFTER] Record log...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><blockquote>
<p>Spring使用AOP配置事务管理由三个部分组成，分别是<strong>DataSource</strong>、<strong>TransactionManager</strong>和<strong>代理机制</strong>这三部分，无论哪种配置方式，一般变化的只是代理机制这部分。DataSource、TransactionManager这两部分只是会根据数据访问方式有所变化，比如使用hibernate进行数据访问时，DataSource实际为SessionFactory，TransactionManager的实现为HibernateTransactionManager。</p>
</blockquote>
<p><img src="http://ov1nop9io.bkt.clouddn.com/644566-20160905080625207-2085618106.png" alt="http://ov1nop9io.bkt.clouddn.com/644566-20160905080625207-2085618106.png"></p>
<blockquote>
<p>spring事务配置的五种方式：每个Bean都有一个代理、所有Bean共享一个代理基类、使用拦截器、<strong>使用tx标签配置的拦截器</strong>、全注解</p>
</blockquote>
<p>1、<strong>使用tx标签配置的拦截器</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--4、配置hibernate属性 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入db.properties属性文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;location&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:db.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源，连接池使用c3p0,详细信息参见hibernate官方文档&quot;基础配置章节&quot; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span> <span class="attr">dependency-check</span>=<span class="string">&quot;none&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;datasource.driverClassName&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;datasource.url&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;datasource.username&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;datasource.password&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。Default: 3 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;c3p0.acquireIncrement&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--初始化时获取的连接数，取值应在minPoolSize与maxPoolSize之间。Default: 3 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;c3p0.initialPoolSize&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--连接池中保留的最小连接数。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;c3p0.minPoolSize&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--连接池中保留的最大连接数。Default: 15 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;c3p0.maxPoolSize&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdleTime&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--最大空闲时间,60秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;c3p0.maxIdleTime&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;idleConnectionTestPeriod&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--每60秒检查所有连接池中的空闲连接。Default: 0 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;c3p0.idleConnectionTestPeriod&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatements&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- JDBC的标准参数，用以控制数据源内加载的PreparedStatements数量。但由于预缓存的statements 属于单个connection而不是整个连接池。所以设置这个参数需要考虑到多方面的因素。 </span></span><br><span class="line"><span class="comment">                如果maxStatements与maxStatementsPerConnection均为0，则缓存被关闭。Default: 0 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;c3p0.maxStatements&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;numHelperThreads&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- C3P0是异步操作的，缓慢的JDBC操作通过帮助进程完成。扩展这些操作可以有效的提升性能， 通过多线程实现多个操作同时被执行。Default: </span></span><br><span class="line"><span class="comment">                3 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;c3p0.numHelperThreads&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置 sessionFactory --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sessionFactory&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- hibernate的设置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernateProperties&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.dialect&quot;</span>&gt;</span>$&#123;hibernate.dialect&#125;<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.show_sql&quot;</span>&gt;</span> $&#123;hibernate.show_sql&#125; <span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.jdbc.fetch_size&quot;</span>&gt;</span>$&#123;hibernate.jdbc.fetch_size&#125;<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.jdbc.batch_size&quot;</span>&gt;</span>$&#123;hibernate.jdbc.batch_size&#125;<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.connection.release_mode&quot;</span>&gt;</span>$&#123;hibernate.connection.release_mode&#125;<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.format_sql&quot;</span>&gt;</span>$&#123;hibernate.format_sql&#125;<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.connection.SetBigStringTryClob&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- anotation注解扫描实体类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;packagesToScan&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.pec.model<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--5、Spring 配置声明式事物 --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 配置事务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 配置事务范围 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;NOT_SUPPORTED&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;NOT_SUPPORTED&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;save*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;delete*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;create*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;anscy*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 定义切面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.pec.service..*.*(..))&quot;</span>  /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>⑴ pointcut中的三个”<em>“中，第一个</em>代表返回值，第二<em>代表service下子包，第三个</em>代表方法名，“（..）”代表方法参数。</p>
<p>⑵ 此时配置的切点在Service层，方法命名需要按照以上advice通知点开头命名。</p>
<p>⑶ 按照规定命名方法，会受到Spring事务的管控，保持操作的一致性。例如向数据库插入100条数据，前面99条记录都正常执行直至第100条出现错误，则事务管控会回滚到执行前的初始状态。</p>
<p><strong>2、使用Bean代理</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">      http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">      http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">      http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">      http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="string"><span class="tag">      http://www.springframework.org/schema/tx/spring-tx-2.5.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">      http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="string"><span class="tag">      http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">default-autowire</span>=<span class="string">&quot;default&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- &lt;bean name=&quot;userManager&quot; class=&quot;com.tgb.manager.UserManagerImpl&quot;&gt;&lt;/bean&gt;</span></span><br><span class="line"><span class="comment">    &lt;bean name=&quot;userController&quot; class=&quot;com.tgb.web.UserController&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name=&quot;userManager&quot; ref=&quot;userManager&quot;&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">    &lt;/bean&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.tgb.dao&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.tgb.entity&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.tgb.manager&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.tgb.web&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 引入init.properties中属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;placeholderConfig&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;locations&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:config/spring/jdbc.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源，连接池使用c3p0,详细信息参见hibernate官方文档&quot;基础配置章节&quot; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;datasource.driverClassName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;datasource.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;datasource.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;datasource.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 配置SessionFactory --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernateProperties&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.dialect&quot;</span>&gt;</span></span><br><span class="line">                    $&#123;hibernate.dialect&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.show_sql&quot;</span>&gt;</span> </span><br><span class="line">                    $&#123;hibernate.show_sql&#125; </span><br><span class="line">                <span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.jdbc.fetch_size&quot;</span>&gt;</span></span><br><span class="line">                    $&#123;hibernate.jdbc.fetch_size&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.jdbc.batch_size&quot;</span>&gt;</span></span><br><span class="line">                    $&#123;hibernate.jdbc.batch_size&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.connection.release_mode&quot;</span>&gt;</span></span><br><span class="line">                    $&#123;hibernate.connection.release_mode&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.format_sql&quot;</span>&gt;</span></span><br><span class="line">                    $&#123;hibernate.format_sql&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;hibernate.connection.SetBigStringTryClob&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- anotation注解扫描实体类  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;annotatedClasses&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.tgb.entity.User<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置一个事务管理器 将事务与Hibernate关联--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.hibernate4.HibernateTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sessionFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 配置事务范围，使用代理的方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionProxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--   为事务代理bean注入事务管理器--&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;transactionManager&quot;</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">         <span class="comment">&lt;!--设置事务属性范围--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;transactionAttributes&quot;</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;add*&quot;</span>&gt;</span>PROPAGATION_REQUIRED,-Exception<span class="tag">&lt;/<span class="name">prop</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;get&quot;</span>&gt;</span>PROPAGATION_REQUIRED,-Exception<span class="tag">&lt;/<span class="name">prop</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;update*&quot;</span>&gt;</span>PROPAGATION_REQUIRED,-myException<span class="tag">&lt;/<span class="name">prop</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;del*&quot;</span>&gt;</span>PROPAGATION_REQUIRED<span class="tag">&lt;/<span class="name">prop</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;*&quot;</span>&gt;</span>PROPAGATION_REQUIRED<span class="tag">&lt;/<span class="name">prop</span>&gt;</span>      </span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tgb.dao.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userManagerBase&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.tgb.manager.UserManagerImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 此处为代理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;userManager&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;transactionProxy&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;target&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userManagerBase&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    </span><br><span class="line">     </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.usherblog.site/2018/02/24/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Usher">
      <meta itemprop="description" content="Honor To The End">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Usher_Ou's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/02/24/JVM/" class="post-title-link" itemprop="url">JVM学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">نُشر في</span>
      

      <time title="أُنشأ: 2018-02-24 19:23:56 / عُدل: 22:42:23" itemprop="dateCreated datePublished" datetime="2018-02-24T19:23:56+08:00">2018-02-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">في</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p><img src="http://ov1nop9io.bkt.clouddn.com/dc695f48-4189-4fc7-b950-ed25f6c80f82.jpg" alt="http://ov1nop9io.bkt.clouddn.com/dc695f48-4189-4fc7-b950-ed25f6c80f82.jpg"></p>
<p>注：白色区域为线程私有的，蓝色区域为线程共享的。</p>
<h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h2><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是 Native 方法则为空）。</p>
<h2 id="2-Java-虚拟机栈"><a href="#2-Java-虚拟机栈" class="headerlink" title="2. Java 虚拟机栈"></a>2. Java 虚拟机栈</h2><p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>
<p>该区域可能抛出以下异常：</p>
<ol>
<li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li>
<li>栈进行动态扩展时如果无法申请导足够内存，会抛出 OutOfMemoryError 异常。</li>
</ol>
<h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h2><p>与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</p>
<h2 id="4-Java-堆"><a href="#4-Java-堆" class="headerlink" title="4. Java 堆"></a>4. Java 堆</h2><p>所有对象实例都在这里分配内存。</p>
<p>这块区域是垃圾收集器管理的主要区域（”GC 堆 “）。现在收集器基本都是采用分代收集算法，Java 堆还可以分成：新生代和老年代（新生代还可以分成 Eden 空间、From Survivor 空间、To Survivor 空间等）。</p>
<p>不需要连续内存，可以通过 -Xmx 和 -Xms 来控制动态扩展内存大小，如果动态扩展失败会抛出 OutOfMemoryError 异常。</p>
<h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h2><p>用于存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>和 Java 堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p>
<p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现，HotSpot 虚拟机把它当成永久代来进行垃圾回收。</p>
<h2 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6. 运行时常量池"></a>6. 运行时常量池</h2><p>运行时常量池是方法区的一部分。</p>
<p>类加载后，Class 文件中的常量池（用于存放编译期生成的各种字面量和符号引用）就会被放到这个区域。</p>
<p>在运行期间也可以用过 String 类的 intern() 方法将新的常量放入该区域。</p>
<h2 id="7-直接内存"><a href="#7-直接内存" class="headerlink" title="7. 直接内存"></a>7. 直接内存</h2><p>在 JDK 1.4 中新加入了 NIO 类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>
<h1 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h1><p>程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。</p>
<p>垃圾回收主要是针对 Java 堆和方法区进行。</p>
<h2 id="1-判断一个对象是否可回收"><a href="#1-判断一个对象是否可回收" class="headerlink" title="1. 判断一个对象是否可回收"></a>1. 判断一个对象是否可回收</h2><h3 id="1-1-引用计数"><a href="#1-1-引用计数" class="headerlink" title="1.1 引用计数"></a>1.1 引用计数</h3><p>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。</p>
<p>引用计数为 0 的对象可被回收。</p>
<p>两个对象会出现循环引用问题，此时引用计数器永远不为 0，导致 GC 收集器无法回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objA.instance = objB;</span><br><span class="line">objB.instance = objA;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-可达性"><a href="#1-2-可达性" class="headerlink" title="1.2 可达性"></a>1.2 可达性</h3><p>通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是都是可用的，不可达的对象可被回收。</p>
<p>GC Roots 一般包含以下内容：</p>
<ol>
<li>虚拟机栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
<li>本地方法栈中引用的对象</li>
</ol>
<h3 id="1-3-引用类型"><a href="#1-3-引用类型" class="headerlink" title="1.3 引用类型"></a>1.3 引用类型</h3><p>无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定独享是否存活都与“引用”有关。</p>
<h4 id="1-3-1-强引用"><a href="#1-3-1-强引用" class="headerlink" title="1.3.1 强引用"></a>1.3.1 强引用</h4><p>只要强引用存在，垃圾回收器永远不会回收调掉被引用的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-软引用"><a href="#1-3-2-软引用" class="headerlink" title="1.3.2 软引用"></a>1.3.2 软引用</h4><p>非必须引用，内存溢出之前进行回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br><span class="line">sf.get();</span><br></pre></td></tr></table></figure>

<p>sf 是对 obj 的一个软引用，通过 sf.get() 方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回 null；</p>
<p>软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。</p>
<h4 id="1-3-3-弱引用"><a href="#1-3-3-弱引用" class="headerlink" title="1.3.3 弱引用"></a>1.3.3 弱引用</h4><p>只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够，都会被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br><span class="line">wf.get();</span><br><span class="line">wf.isEnQueued();</span><br></pre></td></tr></table></figure>

<h4 id="1-3-4-虚引用"><a href="#1-3-4-虚引用" class="headerlink" title="1.3.4 虚引用"></a>1.3.4 虚引用</h4><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj);</span><br><span class="line">obj=<span class="keyword">null</span>;</span><br><span class="line">pf.get();</span><br><span class="line">pf.isEnQueued();</span><br></pre></td></tr></table></figure>

<h3 id="1-3-方法区的回收"><a href="#1-3-方法区的回收" class="headerlink" title="1.3 方法区的回收"></a>1.3 方法区的回收</h3><p>在方法区主要是对常量池的回收和对类的卸载。</p>
<p>常量池的回收和堆中对象回收类似。</p>
<p>类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载：</p>
<ol>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li>
</ol>
<p>可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。</p>
<p>在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGo 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。</p>
<h3 id="1-4-finalize"><a href="#1-4-finalize" class="headerlink" title="1.4 finalize()"></a>1.4 finalize()</h3><p>当一个对象可被回收时，如果该对象有必要执行 finalize() 方法，那么就有可能可能通过在该方法中让对象重新被引用，从而实现自救。</p>
<p>finalize() 类似 C++ 的虚构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p>
<h2 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2. 垃圾收集算法"></a>2. 垃圾收集算法</h2><h3 id="2-1-标记-清除算法"><a href="#2-1-标记-清除算法" class="headerlink" title="2.1 标记 - 清除算法"></a>2.1 标记 - 清除算法</h3><p><img src="https://github.com/CyC2018/InterviewNotes/blob/master/pics/a4248c4b-6c1d-4fb8-a557-86da92d3a294.jpg"></p>
<p>将需要回收的对象进行标记，然后清除。</p>
<p>不足：</p>
<ol>
<li>标记和清除过程效率都不高</li>
<li>会产生大量碎片</li>
</ol>
<p>之后的算法都是基于该算法进行改进。</p>
<h3 id="2-2-复制算法"><a href="#2-2-复制算法" class="headerlink" title="2.2 复制算法"></a>2.2 复制算法</h3><p><img src="http://ov1nop9io.bkt.clouddn.com/a4248c4b-6c1d-4fb8-a557-86da92d3a294.jpg" alt="http://ov1nop9io.bkt.clouddn.com/a4248c4b-6c1d-4fb8-a557-86da92d3a294.jpg"></p>
<p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p>
<p>主要不足是只使用了内存的一半。</p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将内存划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survior 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和 Survivor。HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90 %。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，需要依赖于老年代进行分配担保，也就是借用老年代的空间。</p>
<h3 id="2-3-标记-整理算法"><a href="#2-3-标记-整理算法" class="headerlink" title="2.3 标记 - 整理算法"></a>2.3 标记 - 整理算法</h3><p><img src="http://ov1nop9io.bkt.clouddn.com/902b83ab-8054-4bd2-898f-9a4a0fe52830.jpg" alt="http://ov1nop9io.bkt.clouddn.com/902b83ab-8054-4bd2-898f-9a4a0fe52830.jpg"></p>
<p>让所有存活的对象都向一段移动，然后直接清理掉端边界以外的内存。</p>
<h3 id="2-4-分代收集算法"><a href="#2-4-分代收集算法" class="headerlink" title="2.4 分代收集算法"></a>2.4 分代收集算法</h3><p>现在的商业虚拟机采用分代收集算法，它使用了前面介绍的几种收集算法，根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p>
<p>一般将 Java 堆分为新生代和老年代。</p>
<ol>
<li>新生代使用：复制算法</li>
<li>老年代使用：标记 - 清理 或者 标记 - 整理 算法。</li>
</ol>
<h2 id="3-垃圾收集器"><a href="#3-垃圾收集器" class="headerlink" title="3. 垃圾收集器"></a>3. 垃圾收集器</h2><p><img src="http://ov1nop9io.bkt.clouddn.com/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg" alt="http://ov1nop9io.bkt.clouddn.com/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg"></p>
<p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<h3 id="3-1-Serial-收集器"><a href="#3-1-Serial-收集器" class="headerlink" title="3.1 Serial 收集器"></a>3.1 Serial 收集器</h3><p><img src="http://ov1nop9io.bkt.clouddn.com/22fda4ae-4dd5-489d-ab10-9ebfdad22ae0.jpg" alt="http://ov1nop9io.bkt.clouddn.com/22fda4ae-4dd5-489d-ab10-9ebfdad22ae0.jpg"></p>
<p>它是单线程的收集器，不仅意味着只会使用一个线程进行垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停所有其他工作线程，往往造成过长的等待时间。</p>
<p>它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p>
<p>在 Client 应用场景中，分配给虚拟机管理的内存一般来说不会很大，该收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</p>
<h3 id="3-2-ParNew-收集器"><a href="#3-2-ParNew-收集器" class="headerlink" title="3.2 ParNew 收集器"></a>3.2 ParNew 收集器</h3><p><img src="http://ov1nop9io.bkt.clouddn.com/81538cd5-1bcf-4e31-86e5-e198df1e013b.jpg" alt="http://ov1nop9io.bkt.clouddn.com/81538cd5-1bcf-4e31-86e5-e198df1e013b.jpg"></p>
<p>它是 Serial 收集器的多线程版本。</p>
<p>是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</p>
<p>默认开始的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。</p>
<h3 id="3-3-Parallel-Scavenge-收集器"><a href="#3-3-Parallel-Scavenge-收集器" class="headerlink" title="3.3 Parallel Scavenge 收集器"></a>3.3 Parallel Scavenge 收集器</h3><p>是并行的多线程收集器。</p>
<p>其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
<p>提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 -XX:MaxGCPauseMillis 参数以及直接设置吞吐量大小的 -XX:GCTimeRatio 参数（值为大于 0 且小于 100 的整数）。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p>
<p>还提供了一个参数 -XX:+UseAdaptiveSizePolicy，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 GC 自适应的调节策略（GC Ergonomics）。自适应调节策略也是它与 ParNew 收集器的一个重要区别。</p>
<h3 id="3-4-Serial-Old-收集器"><a href="#3-4-Serial-Old-收集器" class="headerlink" title="3.4 Serial Old 收集器"></a>3.4 Serial Old 收集器</h3><p><img src="http://ov1nop9io.bkt.clouddn.com/08f32fd3-f736-4a67-81ca-295b2a7972f2.jpg" alt="http://ov1nop9io.bkt.clouddn.com/08f32fd3-f736-4a67-81ca-295b2a7972f2.jpg"></p>
<p>Serial Old 是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途：</p>
<ol>
<li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ol>
<h3 id="3-5-Parallel-Old-收集器"><a href="#3-5-Parallel-Old-收集器" class="headerlink" title="3.5 Parallel Old 收集器"></a>3.5 Parallel Old 收集器</h3><p><img src="http://ov1nop9io.bkt.clouddn.com/278fe431-af88-4a95-a895-9c3b80117de3.jpg" alt="http://ov1nop9io.bkt.clouddn.com/278fe431-af88-4a95-a895-9c3b80117de3.jpg"></p>
<p>是 Parallel Scavenge 收集器的老年代版本。</p>
<p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
<h3 id="3-6-CMS-收集器"><a href="#3-6-CMS-收集器" class="headerlink" title="3.6 CMS 收集器"></a>3.6 CMS 收集器</h3><p><img src="http://ov1nop9io.bkt.clouddn.com/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg" alt="http://ov1nop9io.bkt.clouddn.com/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg"></p>
<p>CMS（Concurrent Mark Sweep），从 Mark Sweep 可以知道它是基于 标记 - 清除 算法实现的。</p>
<p>特点：并发收集、低停顿。</p>
<p>分为以下四个流程：</p>
<ol>
<li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li>
<li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li>
<li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li>
<li>并发清除：不需要停顿。</li>
</ol>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p>
<p>具有以下缺点：</p>
<ol>
<li><p>对 CPU 资源敏感。CMS 默认启动的回收线程数是 (CPU 数量 + 3) / 4，当 CPU 不足 4 个时，CMS 对用户程序的影响就可能变得很大，如果本来 CPU 负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了 50%，其实也让人无法接受。并且低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率变低。</p>
</li>
<li><p>无法处理浮动垃圾。由于并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留到下一次 GC 时再清理掉，这一部分垃圾就被称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此它不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。可以使用 -XX:CMSInitiatingOccupancyFraction 的值来改变触发收集器工作的内存占用百分比，JDK 1.5 默认设置下该值为 68，也就是当老年代使用了 68% 的空间之后会触发收集器工作。如果该值设置的太高，导致浮动垃圾无法保存，那么就会出现 Concurrent Mode Failure，此时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集。</p>
</li>
<li><p>标记 - 清除算法导致的空间碎片，给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前出发一次 Full GC。</p>
</li>
</ol>
<h3 id="3-7-G1-收集器"><a href="#3-7-G1-收集器" class="headerlink" title="3.7 G1 收集器"></a>3.7 G1 收集器</h3><p><img src="http://ov1nop9io.bkt.clouddn.com/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg" alt="http://ov1nop9io.bkt.clouddn.com/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg"></p>
<p>G1（Garbage-First）收集器是当今收集器技术发展最前沿的成果之一，它是一款面向服务端应用的垃圾收集器，HotSpot 开发团队赋予它的使命是（在比较长期的）未来可以替换掉 JDK 1.5 中发布的 CMS 收集器。</p>
<p>具备如下特点：</p>
<ul>
<li>并行与并发：能充分利用多 CPU 环境下的硬件优势，使用多个 CPU 来缩短停顿时间；</li>
<li>分代收集：分代概念依然得以保留，虽然它不需要其它收集器配合就能独立管理整个 GC 堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次 GC 的旧对象来获取更好的收集效果。</li>
<li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿：这是它相对 CMS 的一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒，这几乎已经是实时 Java（RTSJ）的垃圾收集器的特征了。</li>
</ul>
<p>在 G1 之前的其他收集器进行收集的范围都是整个新生代或者老生代，而 G1 不再是这样，Java 堆的内存布局与其他收集器有很大区别，将整个 Java 堆划分为多个大小相等的独立区域（Region）。虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，而都是一部分 Region（不需要连续）的集合。</p>
<p>之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。它跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region（这也就是 Garbage-First 名称的来由）。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了它在有限的时间内可以获取尽可能高的收集效率。</p>
<p>Region 不可能是孤立的，一个对象分配在某个 Region 中，可以与整个 Java 堆任意的对象发生引用关系。在做可达性分析确定对象是否存活的时候，需要扫描整个 Java 堆才能保证准确性，这显然是对 GC 效率的极大伤害。为了避免全堆扫描的发生，每个 Region 都维护了一个与之对应的 Remembered Set。虚拟机发现程序在对 Reference 类型的数据进行写操作时，会产生一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 之中，如果是，便通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 的 Remembered Set 之中。当进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。</p>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li>
<li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li>
</ol>
<h3 id="3-8-七种垃圾收集器的比较"><a href="#3-8-七种垃圾收集器的比较" class="headerlink" title="3.8 七种垃圾收集器的比较"></a>3.8 七种垃圾收集器的比较</h3><table>
<thead>
<tr>
<th>收集器</th>
<th>串行、并行 or 并发</th>
<th>新生代 / 老年代</th>
<th>算法</th>
<th>目标</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Serial</strong></td>
<td>串行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>单 CPU 环境下的 Client 模式</td>
</tr>
<tr>
<td><strong>Serial Old</strong></td>
<td>串行</td>
<td>老年代</td>
<td>标记 - 整理</td>
<td>响应速度优先</td>
<td>单 CPU 环境下的 Client 模式、CMS 的后备预案</td>
</tr>
<tr>
<td><strong>ParNew</strong></td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>多 CPU 环境时在 Server 模式下与 CMS 配合</td>
</tr>
<tr>
<td><strong>Parallel Scavenge</strong></td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td><strong>Parallel Old</strong></td>
<td>并行</td>
<td>老年代</td>
<td>标记 - 整理</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td><strong>CMS</strong></td>
<td>并发</td>
<td>老年代</td>
<td>标记 - 清除</td>
<td>响应速度优先</td>
<td>集中在互联网站或 B/S 系统服务端上的 Java 应用</td>
</tr>
<tr>
<td><strong>G1</strong></td>
<td>并发</td>
<td>both</td>
<td>标记 - 整理 + 复制算法</td>
<td>响应速度优先</td>
<td>面向服务端应用，将来替换 CMS</td>
</tr>
</tbody></table>
<h3 id="3-9-垃圾收集器参数总结"><a href="#3-9-垃圾收集器参数总结" class="headerlink" title="3.9 垃圾收集器参数总结"></a>3.9 垃圾收集器参数总结</h3><p>垃圾搜集器选择参数<br>名称    说明    备注<br>UseSerialGC    开启此参数使用serial &amp; serial old搜集器（client模式默认值）。<br>UseParNewGC    开启此参数使用ParNew &amp; serial old搜集器（不推荐）。<br>UseConcMarkSweepGC    开启此参数使用ParNew &amp; CMS（serial old为替补）搜集器。<br>UseParallelGC    开启此参数使用parallel scavenge &amp; parallel old搜集器（server模式默认值）。<br>UseParallelOldGC    开启此参数在年老代使用parallel old搜集器（该参数在JDK1.5之后已无用）。<br>JVM各个内存区域大小相关参数<br>名称    说明    备注<br>Xms    堆的初始值。默认为物理内存的1/64，最大不超1G。<br>Xmx    堆的最大值。默认为物理内存的1/4，最大不超1G。<br>Xmn    新生代的大小。<br>Xss    线程栈大小。<br>PermSize    永久代初始大小。默认为物理内存的1/64，最大不超1G。<br>MaxPermSize    永久代最大值。默认为物理内存的1/4，最大不超1G。<br>NewRatio    新生代与年老代的比例。比如为3，则新生代占堆的1/4，年老代占3/4。<br>SurvivorRatio    新生代中调整eden区与survivor区的比例，默认为8，即eden区为80%的大小，两个survivor分别为10%的大小。<br>垃圾搜集器性能通用参数<br>名称    说明    备注<br>PretenureSizeThreshold    晋升年老代的对象大小。默认为0，比如设为10M，则超过10M的对象将不在eden区分配，而直接进入年老代。<br>MaxTenuringThreshold    晋升老年代的最大年龄。默认为15，比如设为10，则对象在10次普通GC后将会被放入年老代。<br>DisableExplicitGC    禁用System.gc()。<br>并行搜集器参数<br>名称    说明    备注<br>ParallelGCThreads    回收时开启的线程数。默认与CPU个数相等。<br>GCTimeRatio    设置系统的吞吐量。比如设为99，则GC时间比为1/1+99=1%，也就是要求吞吐量为99%。若无法满足会缩小新生代大小。<br>MaxGCPauseMillis    设置垃圾回收的最大停顿时间。若无法满足设置值，则会优先缩小新生代大小，仍无法满足的话则会牺牲吞吐量。<br>并发搜集器参数<br>名称    说明    备注<br>CMSInitiatingOccupancyFraction    触发CMS收集器的内存比例。比如60%的意思就是说，当内存达到60%，就会开始进行CMS并发收集。<br>UseCMSCompactAtFullCollection    在每一次CMS收集器清理垃圾后送一次内存整理。<br>CMSFullGCsBeforeCompaction    设置在几次CMS垃圾收集后，触发一次内存整理。    </p>
<h2 id="4-内存分配与回收策略"><a href="#4-内存分配与回收策略" class="headerlink" title="4. 内存分配与回收策略"></a>4. 内存分配与回收策略</h2><h3 id="4-1-优先在-Eden-分配"><a href="#4-1-优先在-Eden-分配" class="headerlink" title="4.1 优先在 Eden 分配"></a>4.1 优先在 Eden 分配</h3><p>大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC；</p>
<h3 id="4-2-大对象直接进入老年代"><a href="#4-2-大对象直接进入老年代" class="headerlink" title="4.2 大对象直接进入老年代"></a>4.2 大对象直接进入老年代</h3><p>提供 -XX:PretenureSizeThreshold 参数，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制；</p>
<h3 id="4-3-长期存活的对象进入老年代"><a href="#4-3-长期存活的对象进入老年代" class="headerlink" title="4.3 长期存活的对象进入老年代"></a>4.3 长期存活的对象进入老年代</h3><p>JVM 为对象定义年龄计数器，经过 Minor GC 依然存活且被 Survivor 区容纳的，移动到 Survivor 区，年龄加 1，每经历一次 Minor GC 不被清理则年龄加 1，增加到一定年龄则移动到老年区（默认 15 岁，通过 -XX:MaxTenuringThreshold 设置）；</p>
<h3 id="4-4-动态对象年龄判定"><a href="#4-4-动态对象年龄判定" class="headerlink" title="4.4 动态对象年龄判定"></a>4.4 动态对象年龄判定</h3><p>若 Survivor 区中同年龄所有对象大小总和大于 Survivor 空间一半，则年龄大于等于该年龄的对象可以直接进入老年代；</p>
<h3 id="4-5-空间分配担保"><a href="#4-5-空间分配担保" class="headerlink" title="4.5 空间分配担保"></a>4.5 空间分配担保</h3><p>在发生 Minor GC 之前，JVM 先检查老年代最大可用连续空间是否大于新生代所有对象总空间，成立的话 Minor GC 确认是安全的；否则继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，大于的话进行 Minor GC，小于的话进行 Full GC。</p>
<h2 id="4-6-Full-GC-的触发条件"><a href="#4-6-Full-GC-的触发条件" class="headerlink" title="4.6 Full GC 的触发条件"></a>4.6 Full GC 的触发条件</h2><p>对于 Minor GC，其触发条件非常简单，当 Eden 区空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p>
<h3 id="4-6-1-调用-System-gc"><a href="#4-6-1-调用-System-gc" class="headerlink" title="4.6.1 调用 System.gc()"></a>4.6.1 调用 System.gc()</h3><p>此方法的调用是建议 JVM 进行 Full GC，虽然只是建议而非一定，但很多情况下它会触发 Full GC，从而增加 Full GC 的频率，也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存，可通过 -XX:+ DisableExplicitGC 来禁止 RMI 调用 System.gc()。</p>
<h3 id="4-6-2-老年代空间不足"><a href="#4-6-2-老年代空间不足" class="headerlink" title="4.6.2 老年代空间不足"></a>4.6.2 老年代空间不足</h3><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等，当执行 Full GC 后空间仍然不足，则抛出如下错误： Java.lang.OutOfMemoryError: Java heap space 为避免以上两种状况引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p>
<h3 id="4-6-3-空间分配担保失败"><a href="#4-6-3-空间分配担保失败" class="headerlink" title="4.6.3 空间分配担保失败"></a>4.6.3 空间分配担保失败</h3><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果出现了 HandlePromotionFailure 担保失败，则会触发 Full GC。</p>
<h3 id="4-6-4-JDK-1-7-及以前的永久代空间不足"><a href="#4-6-4-JDK-1-7-及以前的永久代空间不足" class="headerlink" title="4.6.4 JDK 1.7 及以前的永久代空间不足"></a>4.6.4 JDK 1.7 及以前的永久代空间不足</h3><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 class 的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation 可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么 JVM 会抛出如下错误信息：java.lang.OutOfMemoryError: PermGen space 为避免 PermGen 占满造成 Full GC 现象，可采用的方法为增大 PermGen 空间或转为使用 CMS GC。</p>
<p>在 JDK 1.8 中用元空间替换了永久代作为方法区的实现，元空间是本地内存，因此减少了一种 Full GC 触发的可能性。</p>
<h3 id="4-6-5-Concurrent-Mode-Failure"><a href="#4-6-5-Concurrent-Mode-Failure" class="headerlink" title="4.6.5 Concurrent Mode Failure"></a>4.6.5 Concurrent Mode Failure</h3><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（有时候“空间不足”是 CMS GC 时当前的浮动垃圾过多导致暂时性的空间不足触发 Full GC），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>
<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p>类是在运行期间动态加载的。</p>
<h2 id="1-类的生命周期"><a href="#1-类的生命周期" class="headerlink" title="1 类的生命周期"></a>1 类的生命周期</h2><p><img src="http://ov1nop9io.bkt.clouddn.com/32b8374a-e822-4720-af0b-c0f485095ea2.jpg" alt="http://ov1nop9io.bkt.clouddn.com/32b8374a-e822-4720-af0b-c0f485095ea2.jpg"></p>
<p>包括以下 7 个阶段：</p>
<ul>
<li><strong>加载（Loading）</strong></li>
<li><strong>验证（Verification）</strong></li>
<li><strong>准备（Preparation）</strong></li>
<li><strong>解析（Resolution）</strong></li>
<li><strong>初始化（Initialization）</strong></li>
<li>使用（Using）</li>
<li>卸载（Unloading）</li>
</ul>
<p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p>
<h2 id="2-类初始化时机"><a href="#2-类初始化时机" class="headerlink" title="2. 类初始化时机"></a>2. 类初始化时机</h2><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化：( 加载、验证、准备都会随着发生 )</p>
<ol>
<li><p>遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译器把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。</p>
</li>
<li><p>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</p>
</li>
<li><p>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
</li>
<li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；</p>
</li>
<li><p>当使用 jdk1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</p>
</li>
</ol>
<p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p>
<p>1. 通过子类引用父类的静态字段，不会导致子类初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(SubClass.value); <span class="comment">// value 字段在 SuperClass 中定义</span></span><br></pre></td></tr></table></figure>

<p>2. 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>3. 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure>

<h2 id="3-类加载过程"><a href="#3-类加载过程" class="headerlink" title="3. 类加载过程"></a>3. 类加载过程</h2><p>包含了加载、验证、准备、解析和初始化这 5 个阶段。</p>
<h3 id="3-1-加载"><a href="#3-1-加载" class="headerlink" title="3.1 加载"></a>3.1 加载</h3><p>加载是类加载的一个阶段，注意不要混淆。</p>
<p>加载过程完成以下三件事：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。</li>
<li>在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>其中二进制字节流可以从以下方式中获取：</p>
<ul>
<li>从 ZIP 包读取，这很常见，最终成为日后 JAR、EAR、WAR 格式的基础。</li>
<li>从网络中获取，这种场景最典型的应用是 Applet。</li>
<li>运行时计算生成，这种场景使用得最多得就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li>
<li>由其他文件生成，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。</li>
<li>从数据库读取，这种场景相对少见，例如有些中间件服务器（如 SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。<br>…</li>
</ul>
<h3 id="3-2-验证"><a href="#3-2-验证" class="headerlink" title="3.2 验证"></a>3.2 验证</h3><p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>主要有以下 4 个阶段：</p>
<ol>
<li>文件格式验证</li>
<li>元数据验证（对字节码描述的信息进行语义分析）</li>
<li>字节码验证（通过数据流和控制流分析，确保程序语义是合法、符合逻辑的，将对类的方法体进行校验分析）</li>
<li>符号引用验证</li>
</ol>
<h3 id="3-3-准备"><a href="#3-3-准备" class="headerlink" title="3.3 准备"></a>3.3 准备</h3><p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。</p>
<p>实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在 Java 堆中。</p>
<p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>如果类变量是常量，那么会按照表达式来进行初始化，而不是赋值为 0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-解析"><a href="#3-4-解析" class="headerlink" title="3.4 解析"></a>3.4 解析</h3><p>将常量池的符号引用替换为直接引用的过程。</p>
<h3 id="3-5-初始化"><a href="#3-5-初始化" class="headerlink" title="3.5 初始化"></a>3.5 初始化</h3><p>初始化阶段即虚拟机执行类构造器 &lt;clinit&gt;() 方法的过程。</p>
<p>在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</p>
<p>&lt;clinit&gt;() 方法具有以下特点：</p>
<ul>
<li>是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;                <span class="comment">// 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.print(i);  <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>与类的构造函数（或者说实例构造器 &lt;init&gt;()）不同，不需要显式的调用父类的构造器。虚拟机会自动保证在子类的 &lt;clinit&gt;() 方法运行之前，父类的 &lt;clinit&gt;() 方法已经执行结束。因此虚拟机中第一个执行 &lt;clinit&gt;() 方法的类肯定为 java.lang.Object。</p>
</li>
<li><p>由于父类的 &lt;clinit&gt;() 方法先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作。例如以下代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            A = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Sub.B);  <span class="comment">// 输出结果是父类中的静态变量值 A，也就是 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>&lt;clinit&gt;() 方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成 &lt;clinit&gt;() 方法。</p>
</li>
<li><p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt;() 方法。</p>
</li>
<li><p>虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕。如果在一个类的 &lt;clinit&gt;() 方法中有耗时的操作，就可能造成多个进程阻塞，在实际过程中此种阻塞很隐蔽。</p>
</li>
</ul>
<h2 id="4-类加载器"><a href="#4-类加载器" class="headerlink" title="4. 类加载器"></a>4. 类加载器</h2><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流 ( 即字节码 )”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<h3 id="4-1-类与类加载器"><a href="#4-1-类与类加载器" class="headerlink" title="4.1 类与类加载器"></a>4.1 类与类加载器</h3><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。通俗而言：比较两个类是否“相等”（这里所指的“相等”，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果，也包括使用 instanceof() 关键字对做对象所属关系判定等情况），只有在这两个类时由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<h3 id="4-2-类加载器分类"><a href="#4-2-类加载器分类" class="headerlink" title="4.2 类加载器分类"></a>4.2 类加载器分类</h3><p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p>
<p>一种是启动类加载器（Bootstrap ClassLoader），这个类加载器用 C++ 实现，是虚拟机自身的一部分；另一种就是所有其他类的加载器，这些类由 Java 实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。</p>
<p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p>
<ul>
<li><p>启动类加载器（Bootstrap ClassLoader） 此类加载器负责将存放在 <JAVA_HOME>\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。 启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，直接使用 null 代替即可。</p>
</li>
<li><p>扩展类加载器（Extension ClassLoader） 这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 <Java_Home>/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</p>
</li>
<li><p>应用程序类加载器（Application ClassLoader） 这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
</ul>
<h3 id="4-3-双亲委派模型"><a href="#4-3-双亲委派模型" class="headerlink" title="4.3 双亲委派模型"></a>4.3 双亲委派模型</h3><p>应用程序都是由三种类加载器相互配合进行加载的，如果有必要，还可以加入自己定义的类加载器。下图展示的类加载器之间的层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器，这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现。</p>
<p><img src="http://ov1nop9io.bkt.clouddn.com/2cdc3ce2-fa82-4c22-baaa-000c07d10473.jpg" alt="http://ov1nop9io.bkt.clou ddn.com/2cdc3ce2-fa82-4c22-baaa-000c07d10473.jpg"></p>
<p><strong>工作过程</strong></p>
<p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载，而是把这个请求委派给父类加载器，每一个层次的加载器都是如此，依次递归，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成此加载请求（它搜索范围中没有找到所需类）时，子加载器才会尝试自己加载。</p>
<p><strong>好处</strong></p>
<p>使用双亲委派模型来组织类加载器之间的关系，使得 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类 java.lang.Object，它存放再 rt.jar 中，无论哪个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型，由各个类加载器自行加载的话，如果用户编写了一个称为｀java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中将会出现多个不同的 Object 类，程序将变得一片混乱。如果开发者尝试编写一个与 rt.jar 类库中已有类重名的 Java 类，将会发现可以正常编译，但是永远无法被加载运行。</p>
<p><strong>实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="comment">//check the class has been loaded or not</span></span><br><span class="line">    Class c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">//if throws the exception , the father can not complete the load</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(resolve) &#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JVM-参数"><a href="#JVM-参数" class="headerlink" title="JVM 参数"></a>JVM 参数</h1><h2 id="GC-优化配置"><a href="#GC-优化配置" class="headerlink" title="GC 优化配置"></a>GC 优化配置</h2><table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms</td>
<td>初始化堆内存大小</td>
</tr>
<tr>
<td>-Xmx</td>
<td>堆内存最大值</td>
</tr>
<tr>
<td>-Xmn</td>
<td>新生代大小</td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>初始化永久代大小</td>
</tr>
<tr>
<td>-XX:MaxPermSize</td>
<td>永久代最大容量</td>
</tr>
</tbody></table>
<h2 id="GC-类型设置"><a href="#GC-类型设置" class="headerlink" title="GC 类型设置"></a>GC 类型设置</h2><table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:+UseSerialGC</td>
<td>串行垃圾回收器</td>
</tr>
<tr>
<td>-XX:+UseParallelGC</td>
<td>并行垃圾回收器</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>并发标记扫描垃圾回收器</td>
</tr>
<tr>
<td>-XX:ParallelCMSThreads=</td>
<td>并发标记扫描垃圾回收器 = 为使用的线程数量</td>
</tr>
<tr>
<td>-XX:+UseG1GC</td>
<td>G1 垃圾回收器</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx12m -Xms3m -Xmn1m -XX:PermSize=20m -XX:MaxPermSize=20m -XX:+UseSerialGC -jar java-application.jar</span><br></pre></td></tr></table></figure>

<h5 id="整理自《《深入理解Java虚拟机-JVM高级特性与最佳实践》》"><a href="#整理自《《深入理解Java虚拟机-JVM高级特性与最佳实践》》" class="headerlink" title="整理自《《深入理解Java虚拟机 JVM高级特性与最佳实践》》"></a>整理自《《深入理解Java虚拟机 JVM高级特性与最佳实践》》</h5><h5 id="参考链接：https-github-com-CyC2018-InterviewNotes-blob-master-notes-JVM-md"><a href="#参考链接：https-github-com-CyC2018-InterviewNotes-blob-master-notes-JVM-md" class="headerlink" title="参考链接：https://github.com/CyC2018/InterviewNotes/blob/master/notes/JVM.md"></a>参考链接：<a target="_blank" rel="noopener" href="https://github.com/CyC2018/InterviewNotes/blob/master/notes/JVM.md">https://github.com/CyC2018/InterviewNotes/blob/master/notes/JVM.md</a></h5>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.usherblog.site/2018/02/13/Hbase-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Usher">
      <meta itemprop="description" content="Honor To The End">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Usher_Ou's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/02/13/Hbase-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/" class="post-title-link" itemprop="url">Hbase 深入浅出</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">نُشر في</span>
      

      <time title="أُنشأ: 2018-02-13 19:23:56 / عُدل: 21:29:41" itemprop="dateCreated datePublished" datetime="2018-02-13T19:23:56+08:00">2018-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">في</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
        </span>
          ، 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop/" itemprop="url" rel="index"><span itemprop="name">hadoop</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Hbase-深入浅出"><a href="#Hbase-深入浅出" class="headerlink" title="Hbase 深入浅出"></a>Hbase 深入浅出</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>HBase是一个分布式的、面向列的开源数据库，该技术来源于 Fay Chang 所撰写的Google论文“Bigtable：一个结构化数据的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F">分布式存储系统</a>”。就像Bigtable利用了Google文件系统（File System）所提供的分布式数据存储一样，HBase在Hadoop之上提供了类似于Bigtable的能力。HBase是Apache的Hadoop项目的子项目。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。另一个不同的是HBase基于列的而不是基于行的模式。</p>
<p>与FUJITSU Cliq等商用大数据产品不同，HBase是Google Bigtable的开源实现，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%B1%BB%E4%BC%BC">类似</a>Google Bigtable利用GFS作为其文件<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8">存储</a>系统，HBase利用Hadoop HDFS作为其<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6">文件</a>存储<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F">系统</a>；Google运行MapReduce来处理Bigtable中的海量<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE">数据</a>，HBase同样利用Hadoop MapReduce来处理HBase中的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B5%B7%E9%87%8F">海量</a>数据；Google Bigtable利用 Chubby作为协同服务，HBase利用Zookeeper作为对应</p>
</blockquote>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><blockquote>
<ol>
<li>Hbase可以往数据里面insert，也可以update一些数据，但update的实际上也是insert，只是插入一个新的时间戳的一行。delete数据，也是insert，只是insert一行带有delete标记的一行。Hbase的所有操作都是追加插入操作。Hbase是一种日志集数据库。它的存储方式，像是日志文件一样。它是批量大量的往硬盘中写，通常都是以文件形式的读写。这个读写速度，取决于硬盘与机器之间的传输有多快。</li>
<li>Hbase中数据可以保存许多不同时间戳的版本（即同一数据可以复制许多不同的版本，准许数据冗余，也是优势）。数据按时间排序，因此Hbase特别适合寻找按照时间排序寻找Top n的场景。找出某个人最近浏览的消息，最近写的N篇博客，N种行为等等，因此Hbase在互联网应用非常多。</li>
<li>Hbase只有主键索引，因此在建模的时候会遇到了问题。例如，在一张表中，很多的列我都想做某种条件的查询。但却只能在主键上建快速查询。</li>
<li>Hbase是列式数据库,列式数据库的优势在于数据分析。</li>
<li>Hbase中的数据都是字符串，没有其他类型。</li>
</ol>
</blockquote>
<h2 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h2><blockquote>
<p>NoSQL 数据库和关系型数据库的设计目的是为了解决不同的问题，NoSQL 数据模型相对简单，它适合应用灵活更强的 IT 系统，不需要预先定义表如构，而且 NoSQL 对数据库性能要求较高，对 PB 级别的数据进行快速的检索，不需要高度的数据一致性及廷迟性的埸景，可以快的跟据 Key-Value 的方式来查看数据。在市埸上有四种NoSQL数据库，分别是：</p>
<ul>
<li>键值存储数据库：Key-Value 的鐽值对，通常用 Hash Table 来实现，这类数据库的查找速度快、简单，易部署，但数据无结构化，如果区部查找会很慢，和应用埸景是内容缓存，快速的检索数据，主要用于大量数据的高访问量负X，也适用于一些日志系统, e.g. Redis, Oracle BDB, Tokyo Cabinet；</li>
<li>列存储数据库：以列族 Column Family 式存储，将同一列数据存在一起，鐽的特点是指向了多少个列，这些列是由列族来实现的，它的好处是查找快速，扩展性非常好以便应用海量数据存储和处理，但功能相对局限，对设计要求很特定的要求，非常适合分布式文件系统 e.g. HBase、Cassandra, Accumulo, Riak；</li>
<li>文档存储数据库：Key-Value 对应的键值时，Value 为结构化数据，更了解 Value 的内容，数据结构不严格，表结构可变它不需要像关系型数据库一样要预先定义表结构，可以看作他是键值数据库的升级版，文档类型处理得力比较好，但查询能力不高，缺乏统一的查询语法。使用埸景是 Web 应用，，e.g. MongoDB, CouchDB, Couchbase Server ；</li>
<li>图形数据库：图结构，它可以提用图结构的算法，比如最佳路线寻址，N度关系查找，使用灵活的图形模型并且能扩展到不同的服务器上，但很多时候要对整个图作计算才能得出需要的信息，这种结构不太适合分布式的集群方案。应用埸景：推荐系统，社交网络和关于结构关系图谱, e.g. Neo4J, Infinite Graph；</li>
</ul>
</blockquote>
<h3 id="NoSQL与RDBMS的区别"><a href="#NoSQL与RDBMS的区别" class="headerlink" title="NoSQL与RDBMS的区别"></a>NoSQL与RDBMS的区别</h3><p><img src="http://ov1nop9io.bkt.clouddn.com/1005794-20170815072006725-2132221664.png" alt="http://ov1nop9io.bkt.clouddn.com/1005794-20170815072006725-2132221664.png"></p>
<blockquote>
<p>NoSQL 与 RDBMS 最大的分别是数据量和读写吞吐量的不同，数据布局和数据访问频率也不同，他们两个应用解决问题的本质也不一样，比如列存储数据库可以快速查找的原因是列族的设计可以在每一次查询中大量减少磁盘 IO 和数据量的访问。NoSQL 数据库很容易支持数据量达 PB 级别的数据，因为它的特性很容易支持分布式水平扩展；但 RDBMS 只能处理 TB+ 级别的数据，如果你的数据场景是要处理很多事务性数据 e.g. 更新和删除，那么还是优先选择关系型数据库 RBDMS，因为NoSQL数据库不太善于频繁的处理数据更新和删除，因为数据是分布在不同的节点上，还有数据是默认有三份副本，如果需要太量的更新操作，那么每台节点上的数据也有一并更新，这太太增加了解决方案的复杂性；NoSQL 遵从 CAP 和 BASE 理论，RDBMS 遵从 ACID 的理论。如果只有上千行和上百万行的数据，则用傅统数据库会比较适合。</p>
</blockquote>
<h3 id="Hbase表结构"><a href="#Hbase表结构" class="headerlink" title="Hbase表结构"></a>Hbase表结构</h3><blockquote>
<p>HBase 是以数据为中心，RDBMS 是以关系为数据，HBase 是 NoSQL 数据库中的列存储数据库，它有以下特点：强一致性读写，自动分片，HBase 通过 Region 分布在集群中，数据增加时，Region 会自动分割并重新分片。RegionServer 自动故障移取，HBase 支持 HDFS 之外的存储文件，HBase 通过 MapReduce 支持大并发处理，HBase 支持以 API 方式访问数据，HBase 以 Bloom Filters 和 Bloom Cache 对大量数据进行查询优化。HBase 适合场景是存在随机读写的埸景，每秒需要在 TB 级别数据上完成数以千计的操作，访问的操作的方式要简单、明确和直接，如果应用只是插入数据而且处理时需要读取全部数据。HBase 不支持二次索引、事务性数据、关联表的操作。HBase 的使用埸景：消息 (Message) 比如点赞，电商中的 SMS/ MMS，有随机读写的能力，局部数据进行 TopN 的查询、简单实体、图数据、指标。</p>
</blockquote>
<p><img src="http://ov1nop9io.bkt.clouddn.com/1005794-20170814194337318-228599821.png" alt="http://ov1nop9io.bkt.clouddn.com/1005794-20170814194337318-228599821.png"></p>
<blockquote>
<ol>
<li><p>HBase 在表中存储数据，而表数据最后存储在 HDFS 上，数据被分割成 HDFS 块 (Block) 存储在集群的多个节点上，以128G为一个 BlockSize；</p>
</li>
<li><p>HBase 是由 Column Family (列族)，Column (列) 和 Row Key (行) 组成的，列族是列的一个集合，列族可以有任意数量的列，e.g. contactinfo:fname, contactinfo:lname 它也可以单独对每个列族进行存储属性优化，比如对 profilephoto 进行压缩存储。</p>
</li>
<li><p>HBase 每一行都有一个 RowKey 用于快速检索，来保证一行数据的完整性，每个 RowKey 就类似于 RDBMS 的主键，HBase 表是基于 RowKey 进行快速检索，行按照排序后进行存储，</p>
</li>
<li><p>HBase 底层磁盘上是按照 Column Family 分开进行存储。这样的好处是相对于行存，占用空间会很小；</p>
</li>
<li><p>HBase 中间的数据是存储在 Cell 中，而且 Cell 是有版本化的，可以自定义保留多少过版本，Cell 为空时不存储。</p>
</li>
</ol>
</blockquote>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="http://ww4.sinaimg.cn/mw690/63503acbjw1f5x1207zfmj20gr0atq4h.jpg" alt="http://ww4.sinaimg.cn/mw690/63503acbjw1f5x1207zfmj20gr0atq4h.jpg"></p>
<blockquote>
<p>HBase采用Master/Slave架构搭建集群，它隶属于Hadoop生态系统，由以下类型节点组成：HMaster节点、HRegionServer节点、ZooKeeper集群，而在底层，它将数据存储于HDFS中，因而涉及到HDFS的NameNode、DataNode等节点。</p>
</blockquote>
<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><blockquote>
<p>Zookeeper Quorum存储-ROOT-表地址、HMaster地址。HRegionServer把自己以Ephedral方式注册到Zookeeper中，HMaster随时感知各个HRegionServer的健康状况。</p>
</blockquote>
<h3 id="HMaster"><a href="#HMaster" class="headerlink" title="HMaster"></a>HMaster</h3><blockquote>
<p> HMaster没有单点问题,HBase中可以启动多个HMaster，通过Zookeeper的Master Election机制保证总有一个Master在运行。<br>  HMaster主要负责Table和Region的管理工作</p>
</blockquote>
<blockquote>
<ol>
<li>实现DDL操作（Data Definition Language，namespace和table的增删改，column familiy的增删改等）。</li>
<li>管理HRegionServer的负载均衡，调整Region分布。</li>
<li>管理和分配HRegion，比如在HRegion split时分配新的HRegion；在HRegionServer退出时迁移其内的HRegion到其他HRegionServer上。</li>
<li>权限控制（ACL）。</li>
</ol>
</blockquote>
<h3 id="HRegionServer"><a href="#HRegionServer" class="headerlink" title="HRegionServer"></a>HRegionServer</h3><blockquote>
<p> HBase中最核心的模块，主要负责响应用户I/O请求，向HDFS文件系统中读写数据。</p>
<ol>
<li>存放和管理本地HRegion。读写HDFS，管理Table中的数据。</li>
<li>Client直接通过HRegionServer读写数据（从HMaster中获取元数据，找到RowKey所在的HRegion/HRegionServer后）。</li>
</ol>
</blockquote>
<h3 id="HRegion"><a href="#HRegion" class="headerlink" title="HRegion"></a>HRegion</h3><p><img src="http://ww2.sinaimg.cn/mw690/63503acbjw1f5x2cuji5gj20k409ddho.jpg" alt="http://ww2.sinaimg.cn/mw690/63503acbjw1f5x2cuji5gj20k409ddho.jpg"></p>
<blockquote>
<p>HBase使用RowKey将表水平切割成多个HRegion，从HMaster的角度，每个HRegion都纪录了它的StartKey和EndKey（第一个HRegion的StartKey为空，最后一个HRegion的EndKey为空），由于RowKey是排序的，因而Client可以通过HMaster快速的定位每个RowKey在哪个HRegion中。HRegion由HMaster分配到相应的HRegionServer中，然后由HRegionServer负责HRegion的启动和管理，和Client的通信，负责数据的读(使用HDFS)。</p>
</blockquote>
<h2 id="常用Shell命令"><a href="#常用Shell命令" class="headerlink" title="常用Shell命令"></a>常用Shell命令</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">显示hbase中的表</span><br><span class="line">list</span><br><span class="line"></span><br><span class="line">创建<span class="keyword">user</span>表，包含info、data两个列族</span><br><span class="line"><span class="keyword">create</span> <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;info1&#x27;</span>, <span class="string">&#x27;data1&#x27;</span></span><br><span class="line"><span class="keyword">create</span> <span class="string">&#x27;user&#x27;</span>, &#123;NAME <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;info&#x27;</span>, VERSIONS <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;3&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">向<span class="keyword">user</span>表中插入信息，<span class="type">row</span> key为rk0001，列族info中添加name列标示符，值为zhangsan</span><br><span class="line">put <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;rk0001&#x27;</span>, <span class="string">&#x27;info:name&#x27;</span>, <span class="string">&#x27;zhangsan&#x27;</span></span><br><span class="line"></span><br><span class="line">向<span class="keyword">user</span>表中插入信息，<span class="type">row</span> key为rk0001，列族info中添加gender列标示符，值为female</span><br><span class="line">put <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;rk0001&#x27;</span>, <span class="string">&#x27;info:gender&#x27;</span>, <span class="string">&#x27;female&#x27;</span></span><br><span class="line"></span><br><span class="line">向<span class="keyword">user</span>表中插入信息，<span class="type">row</span> key为rk0001，列族info中添加age列标示符，值为<span class="number">20</span></span><br><span class="line">put <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;rk0001&#x27;</span>, <span class="string">&#x27;info:age&#x27;</span>, <span class="number">20</span></span><br><span class="line"></span><br><span class="line">向<span class="keyword">user</span>表中插入信息，<span class="type">row</span> key为rk0001，列族data中添加pic列标示符，值为picture</span><br><span class="line">put <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;rk0001&#x27;</span>, <span class="string">&#x27;data:pic&#x27;</span>, <span class="string">&#x27;picture&#x27;</span></span><br><span class="line"></span><br><span class="line">获取<span class="keyword">user</span>表中<span class="type">row</span> key为rk0001的所有信息</span><br><span class="line"><span class="keyword">get</span> <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;rk0001&#x27;</span></span><br><span class="line"></span><br><span class="line">获取<span class="keyword">user</span>表中<span class="type">row</span> key为rk0001，info列族的所有信息</span><br><span class="line"><span class="keyword">get</span> <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;rk0001&#x27;</span>, <span class="string">&#x27;info&#x27;</span></span><br><span class="line"></span><br><span class="line">获取<span class="keyword">user</span>表中<span class="type">row</span> key为rk0001，info列族的name、age列标示符的信息</span><br><span class="line"><span class="keyword">get</span> <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;rk0001&#x27;</span>, <span class="string">&#x27;info:name&#x27;</span>, <span class="string">&#x27;info:age&#x27;</span></span><br><span class="line"></span><br><span class="line">获取<span class="keyword">user</span>表中<span class="type">row</span> key为rk0001，info、data列族的信息</span><br><span class="line"><span class="keyword">get</span> <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;rk0001&#x27;</span>, <span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;data&#x27;</span></span><br><span class="line"><span class="keyword">get</span> <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;rk0001&#x27;</span>, &#123;<span class="keyword">COLUMN</span> <span class="operator">=</span><span class="operator">&gt;</span> [<span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;data&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">get</span> <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;rk0001&#x27;</span>, &#123;<span class="keyword">COLUMN</span> <span class="operator">=</span><span class="operator">&gt;</span> [<span class="string">&#x27;info:name&#x27;</span>, <span class="string">&#x27;data:pic&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line">获取<span class="keyword">user</span>表中<span class="type">row</span> key为rk0001，列族为info，版本号最新<span class="number">5</span>个的信息</span><br><span class="line"><span class="keyword">get</span> <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;rk0001&#x27;</span>, &#123;<span class="keyword">COLUMN</span> <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;info&#x27;</span>, VERSIONS <span class="operator">=</span><span class="operator">&gt;</span> <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">get</span> <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;rk0001&#x27;</span>, &#123;<span class="keyword">COLUMN</span> <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;info:name&#x27;</span>, VERSIONS <span class="operator">=</span><span class="operator">&gt;</span> <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">get</span> <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;rk0001&#x27;</span>, &#123;<span class="keyword">COLUMN</span> <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;info:name&#x27;</span>, VERSIONS <span class="operator">=</span><span class="operator">&gt;</span> <span class="number">5</span>, TIMERANGE <span class="operator">=</span><span class="operator">&gt;</span> [<span class="number">1392368783980</span>, <span class="number">1392380169184</span>]&#125;</span><br><span class="line"></span><br><span class="line">获取<span class="keyword">user</span>表中<span class="type">row</span> key为rk0001，cell的值为zhangsan的信息</span><br><span class="line"><span class="keyword">get</span> <span class="string">&#x27;people&#x27;</span>, <span class="string">&#x27;rk0001&#x27;</span>, &#123;<span class="keyword">FILTER</span> <span class="operator">=</span><span class="operator">&gt;</span> &quot;ValueFilter(=, &#x27;binary:图片&#x27;)&quot;&#125;</span><br><span class="line"></span><br><span class="line">获取<span class="keyword">user</span>表中<span class="type">row</span> key为rk0001，列标示符中含有a的信息</span><br><span class="line"><span class="keyword">get</span> <span class="string">&#x27;people&#x27;</span>, <span class="string">&#x27;rk0001&#x27;</span>, &#123;<span class="keyword">FILTER</span> <span class="operator">=</span><span class="operator">&gt;</span> &quot;(QualifierFilter(=,&#x27;substring:a&#x27;))&quot;&#125;</span><br><span class="line"></span><br><span class="line">put <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;rk0002&#x27;</span>, <span class="string">&#x27;info:name&#x27;</span>, <span class="string">&#x27;fanbingbing&#x27;</span></span><br><span class="line">put <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;rk0002&#x27;</span>, <span class="string">&#x27;info:gender&#x27;</span>, <span class="string">&#x27;female&#x27;</span></span><br><span class="line">put <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;rk0002&#x27;</span>, <span class="string">&#x27;info:nationality&#x27;</span>, <span class="string">&#x27;中国&#x27;</span></span><br><span class="line"><span class="keyword">get</span> <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;rk0002&#x27;</span>, &#123;<span class="keyword">FILTER</span> <span class="operator">=</span><span class="operator">&gt;</span> &quot;ValueFilter(=, &#x27;binary:中国&#x27;)&quot;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查询<span class="keyword">user</span>表中的所有信息</span><br><span class="line">scan <span class="string">&#x27;user&#x27;</span></span><br><span class="line"></span><br><span class="line">查询<span class="keyword">user</span>表中列族为info的信息</span><br><span class="line">scan <span class="string">&#x27;user&#x27;</span>, &#123;COLUMNS <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;info&#x27;</span>&#125;</span><br><span class="line">scan <span class="string">&#x27;user&#x27;</span>, &#123;COLUMNS <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;info&#x27;</span>, RAW <span class="operator">=</span><span class="operator">&gt;</span> <span class="literal">true</span>, VERSIONS <span class="operator">=</span><span class="operator">&gt;</span> <span class="number">5</span>&#125;</span><br><span class="line">scan <span class="string">&#x27;persion&#x27;</span>, &#123;COLUMNS <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;info&#x27;</span>, RAW <span class="operator">=</span><span class="operator">&gt;</span> <span class="literal">true</span>, VERSIONS <span class="operator">=</span><span class="operator">&gt;</span> <span class="number">3</span>&#125;</span><br><span class="line">查询<span class="keyword">user</span>表中列族为info和data的信息</span><br><span class="line">scan <span class="string">&#x27;user&#x27;</span>, &#123;COLUMNS <span class="operator">=</span><span class="operator">&gt;</span> [<span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;data&#x27;</span>]&#125;</span><br><span class="line">scan <span class="string">&#x27;user&#x27;</span>, &#123;COLUMNS <span class="operator">=</span><span class="operator">&gt;</span> [<span class="string">&#x27;info:name&#x27;</span>, <span class="string">&#x27;data:pic&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查询<span class="keyword">user</span>表中列族为info、列标示符为name的信息</span><br><span class="line">scan <span class="string">&#x27;user&#x27;</span>, &#123;COLUMNS <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;info:name&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">查询<span class="keyword">user</span>表中列族为info、列标示符为name的信息,并且版本最新的<span class="number">5</span>个</span><br><span class="line">scan <span class="string">&#x27;user&#x27;</span>, &#123;COLUMNS <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;info:name&#x27;</span>, VERSIONS <span class="operator">=</span><span class="operator">&gt;</span> <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">查询<span class="keyword">user</span>表中列族为info和data且列标示符中含有a字符的信息</span><br><span class="line">scan <span class="string">&#x27;user&#x27;</span>, &#123;COLUMNS <span class="operator">=</span><span class="operator">&gt;</span> [<span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;data&#x27;</span>], <span class="keyword">FILTER</span> <span class="operator">=</span><span class="operator">&gt;</span> &quot;(QualifierFilter(=,&#x27;substring:a&#x27;))&quot;&#125;</span><br><span class="line"></span><br><span class="line">查询<span class="keyword">user</span>表中列族为info，rk范围是[rk0001, rk0003)的数据</span><br><span class="line">scan <span class="string">&#x27;people&#x27;</span>, &#123;COLUMNS <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;info&#x27;</span>, STARTROW <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;rk0001&#x27;</span>, ENDROW <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;rk0003&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">查询<span class="keyword">user</span>表中<span class="type">row</span> key以rk字符开头的</span><br><span class="line">scan <span class="string">&#x27;user&#x27;</span>,&#123;<span class="keyword">FILTER</span><span class="operator">=</span><span class="operator">&gt;</span>&quot;PrefixFilter(&#x27;rk&#x27;)&quot;&#125;</span><br><span class="line"></span><br><span class="line">查询<span class="keyword">user</span>表中指定范围的数据</span><br><span class="line">scan <span class="string">&#x27;user&#x27;</span>, &#123;TIMERANGE <span class="operator">=</span><span class="operator">&gt;</span> [<span class="number">1392368783980</span>, <span class="number">1392380169184</span>]&#125;</span><br><span class="line"></span><br><span class="line">删除数据</span><br><span class="line">删除<span class="keyword">user</span>表<span class="type">row</span> key为rk0001，列标示符为info:name的数据</span><br><span class="line"><span class="keyword">delete</span> <span class="string">&#x27;people&#x27;</span>, <span class="string">&#x27;rk0001&#x27;</span>, <span class="string">&#x27;info:name&#x27;</span></span><br><span class="line">删除<span class="keyword">user</span>表<span class="type">row</span> key为rk0001，列标示符为info:name，<span class="type">timestamp</span>为<span class="number">1392383705316</span>的数据</span><br><span class="line"><span class="keyword">delete</span> <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;rk0001&#x27;</span>, <span class="string">&#x27;info:name&#x27;</span>, <span class="number">1392383705316</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">清空<span class="keyword">user</span>表中的数据</span><br><span class="line"><span class="keyword">truncate</span> <span class="string">&#x27;people&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改表结构</span><br><span class="line">首先停用<span class="keyword">user</span>表（新版本不用）</span><br><span class="line">disable <span class="string">&#x27;user&#x27;</span></span><br><span class="line"></span><br><span class="line">添加两个列族f1和f2</span><br><span class="line"><span class="keyword">alter</span> <span class="string">&#x27;people&#x27;</span>, NAME <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;f1&#x27;</span></span><br><span class="line"><span class="keyword">alter</span> <span class="string">&#x27;user&#x27;</span>, NAME <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;f2&#x27;</span></span><br><span class="line">启用表</span><br><span class="line">enable <span class="string">&#x27;user&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###disable <span class="string">&#x27;user&#x27;</span>(新版本不用)</span><br><span class="line">删除一个列族：</span><br><span class="line"><span class="keyword">alter</span> <span class="string">&#x27;user&#x27;</span>, NAME <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;f1&#x27;</span>, <span class="keyword">METHOD</span> <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;delete&#x27;</span> 或 <span class="keyword">alter</span> <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;delete&#x27;</span> <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;f1&#x27;</span></span><br><span class="line"></span><br><span class="line">添加列族f1同时删除列族f2</span><br><span class="line"><span class="keyword">alter</span> <span class="string">&#x27;user&#x27;</span>, &#123;NAME <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;f1&#x27;</span>&#125;, &#123;NAME <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;f2&#x27;</span>, <span class="keyword">METHOD</span> <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;delete&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">将<span class="keyword">user</span>表的f1列族版本号改为<span class="number">5</span></span><br><span class="line"><span class="keyword">alter</span> <span class="string">&#x27;people&#x27;</span>, NAME <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;info&#x27;</span>, VERSIONS <span class="operator">=</span><span class="operator">&gt;</span> <span class="number">5</span></span><br><span class="line">启用表</span><br><span class="line">enable <span class="string">&#x27;user&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">删除表</span><br><span class="line">disable <span class="string">&#x27;user&#x27;</span></span><br><span class="line"><span class="keyword">drop</span> <span class="string">&#x27;user&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">get</span> <span class="string">&#x27;person&#x27;</span>, <span class="string">&#x27;rk0001&#x27;</span>, &#123;<span class="keyword">FILTER</span> <span class="operator">=</span><span class="operator">&gt;</span> &quot;ValueFilter(=, &#x27;binary:中国&#x27;)&quot;&#125;</span><br><span class="line"><span class="keyword">get</span> <span class="string">&#x27;person&#x27;</span>, <span class="string">&#x27;rk0001&#x27;</span>, &#123;<span class="keyword">FILTER</span> <span class="operator">=</span><span class="operator">&gt;</span> &quot;(QualifierFilter(=,&#x27;substring:a&#x27;))&quot;&#125;</span><br><span class="line">scan <span class="string">&#x27;person&#x27;</span>, &#123;COLUMNS <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;info:name&#x27;</span>&#125;</span><br><span class="line">scan <span class="string">&#x27;person&#x27;</span>, &#123;COLUMNS <span class="operator">=</span><span class="operator">&gt;</span> [<span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;data&#x27;</span>], <span class="keyword">FILTER</span> <span class="operator">=</span><span class="operator">&gt;</span> &quot;(QualifierFilter(=,&#x27;substring:a&#x27;))&quot;&#125;</span><br><span class="line">scan <span class="string">&#x27;person&#x27;</span>, &#123;COLUMNS <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;info&#x27;</span>, STARTROW <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;rk0001&#x27;</span>, ENDROW <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;rk0003&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">scan <span class="string">&#x27;person&#x27;</span>, &#123;COLUMNS <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;info&#x27;</span>, STARTROW <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;20140201&#x27;</span>, ENDROW <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;20140301&#x27;</span>&#125;</span><br><span class="line">scan <span class="string">&#x27;person&#x27;</span>, &#123;COLUMNS <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;info:name&#x27;</span>, TIMERANGE <span class="operator">=</span><span class="operator">&gt;</span> [<span class="number">1395978233636</span>, <span class="number">1395987769587</span>]&#125;</span><br><span class="line"><span class="keyword">delete</span> <span class="string">&#x27;person&#x27;</span>, <span class="string">&#x27;rk0001&#x27;</span>, <span class="string">&#x27;info:name&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="string">&#x27;person&#x27;</span>, NAME <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;ffff&#x27;</span></span><br><span class="line"><span class="keyword">alter</span> <span class="string">&#x27;person&#x27;</span>, NAME <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;info&#x27;</span>, VERSIONS <span class="operator">=</span><span class="operator">&gt;</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">get</span> <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;rk0002&#x27;</span>, &#123;<span class="keyword">COLUMN</span> <span class="operator">=</span><span class="operator">&gt;</span> [<span class="string">&#x27;info:name&#x27;</span>, <span class="string">&#x27;data:pic&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.usherblog.site/2018/02/02/ItemCF%20%E5%9F%BA%E4%BA%8E%E7%89%A9%E5%93%81%E7%9A%84%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Usher">
      <meta itemprop="description" content="Honor To The End">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Usher_Ou's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/02/02/ItemCF%20%E5%9F%BA%E4%BA%8E%E7%89%A9%E5%93%81%E7%9A%84%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">ItemCF 基于物品的协同过滤算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">نُشر في</span>
      

      <time title="أُنشأ: 2018-02-02 19:23:56 / عُدل: 20:50:47" itemprop="dateCreated datePublished" datetime="2018-02-02T19:23:56+08:00">2018-02-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">في</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
        </span>
          ، 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop/" itemprop="url" rel="index"><span itemprop="name">hadoop</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ItemCF-基于物品的协同过滤算法"><a href="#ItemCF-基于物品的协同过滤算法" class="headerlink" title="ItemCF 基于物品的协同过滤算法"></a>ItemCF 基于物品的协同过滤算法</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><blockquote>
<p>ItemCF：ItemCollaborationFilter，基于物品的协同过滤</p>
<p>算法核心思想：给用户推荐那些和他们之前喜欢的物品相似的物品。</p>
<p>比如，用户A之前买过《数据挖掘导论》，该算法会根据此行为给你推荐《机器学习》，但是ItemCF算法并不利用物品的内容属性计算物品之间的相似度，它主要通过分析用户的行为记录计算物品之间的相似度。</p>
<p>==&gt;该算法认为，物品A和物品B具有很大的相似度是因为喜欢物品A的用户大都也喜欢物品B。</p>
</blockquote>
<h2 id="2、原理"><a href="#2、原理" class="headerlink" title="2、原理"></a>2、原理</h2><p><img src="http://ov1nop9io.bkt.clouddn.com/1008304-20170302233332454-515456069.jpg" alt="http://ov1nop9io.bkt.clouddn.com/1008304-20170302233332454-515456069.jpg"></p>
<p><img src="http://ov1nop9io.bkt.clouddn.com/1008304-20170302233332782-1213533378.jpg" alt="http://ov1nop9io.bkt.clouddn.com/1008304-20170302233332782-1213533378.jpg"></p>
<p><img src="http://ov1nop9io.bkt.clouddn.com/1008304-20170302233333235-1610357057.jpg" alt="http://ov1nop9io.bkt.clouddn.com/1008304-20170302233333235-1610357057.jpg"></p>
<h2 id="3、算法实现"><a href="#3、算法实现" class="headerlink" title="3、算法实现"></a>3、算法实现</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><blockquote>
<p>1．  建立物品的同现矩阵A，即统计两两物品同时出现的次数</p>
<p>数据格式：Item_id1:Item_id2        次数</p>
<p>2．  建立用户对物品的评分矩阵B，即每一个用户对某一物品的评分</p>
<p>数据格式：Item_id          user_id:preference</p>
<p>3．  推荐结果=物品的同现矩阵A * 用户对物品的评分矩阵B</p>
<p>数据格式：user_id           item_id,推荐分值</p>
<ol start="4">
<li>过滤用户已评分的物品项</li>
</ol>
<p>5.对推荐结果按推荐分值从高到低排序</p>
</blockquote>
<h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><blockquote>
<p>1,101,5.0</p>
<p>1,102,3.0</p>
<p>1,103,2.5</p>
<p>2,101,2.0</p>
<p>2,102,2.5</p>
<p>2,103,5.0</p>
<p>2,104,2.0</p>
<p>3,101,2.0</p>
<p>3,104,4.0</p>
<p>3,105,4.5</p>
<p>3,107,5.0</p>
<p>4,101,5.0</p>
<p>4,103,3.0</p>
<p>4,104,4.5</p>
<p>4,106,4.0</p>
<p>5,101,4.0</p>
<p>5,102,3.0</p>
<p>5,103,2.0</p>
<p>5,104,4.0</p>
<p>5,105,3.5</p>
<p>5,106,4.0</p>
<p>6,102,4.0</p>
<p>6,103,2.0</p>
<p>6,105,3.5</p>
<p>6,107,4.0</p>
</blockquote>
<h3 id="Hadoop-MapReduce程序分为四步："><a href="#Hadoop-MapReduce程序分为四步：" class="headerlink" title="Hadoop MapReduce程序分为四步："></a>Hadoop MapReduce程序分为四步：</h3><h4 id="第一步：读取原始数据，按用户ID分组，输出文件数据格式为"><a href="#第一步：读取原始数据，按用户ID分组，输出文件数据格式为" class="headerlink" title="第一步：读取原始数据，按用户ID分组，输出文件数据格式为"></a>第一步：读取原始数据，按用户ID分组，输出文件数据格式为</h4><blockquote>
<p>101:5.0,102:3.0, 103:2.5                    —id=1<br>101:2.0,102:2.5,103:5.0,104:2.0              —id=2<br>101:2.0,104:4.0,105:4.5, 107:5.0              —id=3<br>101:5.0,103:3.0,106:4.0,104:4.5              —id=4<br>101:4.0,102:3.0,103:2.0,104:4.0,105:3.5,106:4.0 —id=5<br>102:4.0,103:2.0,105:3.5,107:4.0              —id=6</p>
</blockquote>
<h4 id="第二步：统计两两物品同时出现的次数（同一个人买2个物品的出现次数），输出文件数据格式为"><a href="#第二步：统计两两物品同时出现的次数（同一个人买2个物品的出现次数），输出文件数据格式为" class="headerlink" title="第二步：统计两两物品同时出现的次数（同一个人买2个物品的出现次数），输出文件数据格式为"></a>第二步：统计两两物品同时出现的次数（同一个人买2个物品的出现次数），输出文件数据格式为</h4><blockquote>
<p>101:101 5<br>101:102 3<br>101:103 4<br>101:104 4<br>101:105 2<br>101:106 2<br>101:107 1<br>102:101 3<br>102:102 4<br>102:103 4<br>102:104 2<br>102:105 2<br>102:106 1<br>102:107 1<br>103:101 4<br>103:102 4<br>103:103 5<br>103:104 3<br>103:105 2<br>103:106 2<br>103:107 1<br>104:101 4<br>104:102 2<br>104:103 3<br>104:104 4<br>104:105 2<br>104:106 2<br>104:107 1<br>105:101 2<br>105:102 2<br>105:103 2<br>105:104 2<br>105:105 3<br>105:106 1<br>105:107 2<br>106:101 2<br>106:102 1<br>106:103 2<br>106:104 2<br>106:105 1<br>106:106 2<br>107:101 1<br>107:102 1<br>107:103 1<br>107:104 1<br>107:105 2<br>107:107 2</p>
</blockquote>
<h4 id="第三步：生成用户评分矩阵和物品同现矩阵第一个mapper结果为用户评分矩阵，结果如下："><a href="#第三步：生成用户评分矩阵和物品同现矩阵第一个mapper结果为用户评分矩阵，结果如下：" class="headerlink" title="第三步：生成用户评分矩阵和物品同现矩阵第一个mapper结果为用户评分矩阵，结果如下："></a>第三步：生成用户评分矩阵和物品同现矩阵第一个mapper结果为用户评分矩阵，结果如下：</h4><blockquote>
<p>Item_id    user_id:preference<br>101       2:2.0<br>101       5:4.0<br>101       4:5.0<br>101       3:2.0<br>101       1:5.0<br>102       2:2.5<br>102       1:3.0<br>102       6:4.0<br>102       5:3.0<br>103       6:2.0<br>103       5:2.0<br>103       1:2.5<br>103       4:3.0<br>103       2:5.0<br>104       5:4.0<br>104       2:2.0<br>104       3:4.0<br>104       4:4.5<br>105       5:3.5<br>105       3:4.5<br>105       6:3.5<br>106       4:4.0<br>106       5:4.0<br>107       3:5.0<br>107       6:4.0</p>
</blockquote>
<h4 id="第二个mapper生成物品同现矩阵，结果如下："><a href="#第二个mapper生成物品同现矩阵，结果如下：" class="headerlink" title="第二个mapper生成物品同现矩阵，结果如下："></a>第二个mapper生成物品同现矩阵，结果如下：</h4><blockquote>
<p>Item_id1:Item_id2        次数<br>101:101 5<br>101:102 3<br>101:103 4<br>101:104 4<br>101:105 2<br>101:106 2<br>101:107 1<br>102:101 3<br>102:102 4<br>102:103 4<br>102:104 2<br>102:105 2<br>102:106 1<br>102:107 1<br>103:101 4<br>103:102 4<br>103:103 5<br>103:104 3<br>103:105 2<br>103:106 2<br>103:107 1<br>104:101 4<br>104:102 2<br>104:103 3<br>104:104 4<br>104:105 2<br>104:106 2<br>104:107 1<br>105:101 2<br>105:102 2<br>105:103 2<br>105:104 2<br>105:105 3<br>105:106 1<br>105:107 2<br>106:101 2<br>106:102 1<br>106:103 2<br>106:104 2<br>106:105 1<br>106:106 2<br>107:101 1<br>107:102 1<br>107:103 1<br>107:104 1<br>107:105 2<br>107:107 2</p>
</blockquote>
<h4 id="第四步：做矩阵乘法，推荐结果-物品的同现矩阵A-用户对物品的评分矩阵B"><a href="#第四步：做矩阵乘法，推荐结果-物品的同现矩阵A-用户对物品的评分矩阵B" class="headerlink" title="第四步：做矩阵乘法，推荐结果=物品的同现矩阵A * 用户对物品的评分矩阵B"></a>第四步：做矩阵乘法，推荐结果=物品的同现矩阵A * 用户对物品的评分矩阵B</h4><blockquote>
<p>user_id    item_id,推荐分值<br>1         107,10.5<br>1         106,18.0<br>1         105,21.0<br>1         104,33.5<br>1         103,44.5<br>1         102,37.0<br>1         101,44.0<br>2         107,11.5<br>2         106,20.5<br>2         105,23.0<br>2         104,36.0<br>2         103,49.0<br>2         102,40.0<br>2         101,45.5<br>3         107,25.0<br>3         106,16.5<br>3         105,35.5<br>3         104,38.0<br>3         103,34.0<br>3         102,28.0<br>3         101,40.0<br>4         107,12.5<br>4         106,33.0<br>4         105,29.0<br>4         104,55.0<br>4         103,56.5<br>4         102,40.0<br>4         101,63.0<br>5         107,20.0<br>5         106,34.5<br>5         105,40.5<br>5         104,59.0<br>5         103,65.0<br>5         102,51.0<br>5         101,68.0<br>6         107,21.0<br>6         106,11.5<br>6         105,30.5<br>6         104,25.0<br>6         103,37.0<br>6         102,35.0<br>6         101,31.0</p>
</blockquote>
<p><img src="http://ov1nop9io.bkt.clouddn.com/fd.png" alt="enter image description here"></p>
<h3 id="MR实现步骤"><a href="#MR实现步骤" class="headerlink" title="MR实现步骤"></a>MR实现步骤</h3><h4 id="第一个MR-就是把输入数据的每个用户的信息整合下"><a href="#第一个MR-就是把输入数据的每个用户的信息整合下" class="headerlink" title="第一个MR 就是把输入数据的每个用户的信息整合下"></a>第一个MR 就是把输入数据的每个用户的信息整合下</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">userid:<span class="number">1</span>,vector:&#123;<span class="number">103</span>:<span class="number">2.5</span>,<span class="number">102</span>:<span class="number">3.0</span>,<span class="number">101</span>:<span class="number">5.0</span>&#125;  </span><br><span class="line">userid:<span class="number">2</span>,vector:&#123;<span class="number">104</span>:<span class="number">2.0</span>,<span class="number">103</span>:<span class="number">5.0</span>,<span class="number">102</span>:<span class="number">2.5</span>,<span class="number">101</span>:<span class="number">2.0</span>&#125;  </span><br><span class="line">userid:<span class="number">3</span>,vector:&#123;<span class="number">107</span>:<span class="number">5.0</span>,<span class="number">105</span>:<span class="number">4.5</span>,<span class="number">104</span>:<span class="number">4.0</span>,<span class="number">101</span>:<span class="number">2.5</span>&#125;  </span><br><span class="line">userid:<span class="number">4</span>,vector:&#123;<span class="number">106</span>:<span class="number">4.0</span>,<span class="number">104</span>:<span class="number">4.5</span>,<span class="number">103</span>:<span class="number">3.0</span>,<span class="number">101</span>:<span class="number">5.0</span>&#125;  </span><br><span class="line">userid:<span class="number">5</span>,vector:&#123;<span class="number">106</span>:<span class="number">4.0</span>,<span class="number">105</span>:<span class="number">3.5</span>,<span class="number">104</span>:<span class="number">4.0</span>,<span class="number">103</span>:<span class="number">2.0</span>,<span class="number">102</span>:<span class="number">3.0</span>,<span class="number">101</span>:<span class="number">4.0</span>&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key,Text value,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>&#123;  </span><br><span class="line">         </span><br><span class="line">VarLongWritable userID=<span class="keyword">new</span> VarLongWritable();  </span><br><span class="line">LongWritable itemID=<span class="keyword">new</span> LongWritable();  </span><br><span class="line">FloatWritable itemValue=<span class="keyword">new</span> FloatWritable();  </span><br><span class="line">String line=value.toString();  </span><br><span class="line">String[] info=line.split(<span class="string">&quot;,&quot;</span>);  </span><br><span class="line"><span class="keyword">if</span>(info.length!=<span class="number">3</span>)&#123; <span class="keyword">return</span>; &#125;    <span class="comment">//uid,itemid,preference</span></span><br><span class="line">userID.set(Long.parseLong(info[<span class="number">0</span>]));  </span><br><span class="line">itemID.set(Long.parseLong(info[<span class="number">1</span>]));  </span><br><span class="line">itemValue.set(Float.parseFloat(info[<span class="number">2</span>]));  </span><br><span class="line">context.write(userID, <span class="keyword">new</span> LongAndFloat(itemID,itemValue));  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WiKiReducer1</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">VarLongWritable</span>,<span class="title">LongAndFloat</span>,<span class="title">VarLongWritable</span>,<span class="title">VectorWritable</span>&gt; </span>&#123;  </span><br><span class="line">      </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(VarLongWritable userID,Iterable&lt;LongAndFloat&gt; itemPrefs,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>&#123;  </span><br><span class="line">            <span class="comment">// RandomAccessSparseVector(int cardinality, int initialCapacity)   </span></span><br><span class="line">            Vector userVector=<span class="keyword">new</span> RandomAccessSparseVector(Integer.MAX_VALUE,<span class="number">10</span>);  </span><br><span class="line">            <span class="keyword">for</span>(LongAndFloat itemPref:itemPrefs)&#123;  </span><br><span class="line">                userVector.set(Integer.parseInt(itemPref.getFirst().toString()),Float.parseFloat(itemPref.getSecond().toString()) );  </span><br><span class="line">            &#125;  </span><br><span class="line">            context.write(userID, <span class="keyword">new</span> VectorWritable(userVector));  </span><br><span class="line">    <span class="comment">//      System.out.println(&quot;userid:&quot;+userID+&quot;,vector:&quot;+userVector);  </span></span><br><span class="line">        &#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="类-LongAndFloat-用于存储数据并实现Writable的数据类型"><a href="#类-LongAndFloat-用于存储数据并实现Writable的数据类型" class="headerlink" title="类 LongAndFloat 用于存储数据并实现Writable的数据类型"></a>类 LongAndFloat 用于存储数据并实现Writable的数据类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAndFloat</span> <span class="keyword">implements</span> <span class="title">WritableComparable</span>&lt;<span class="title">LongAndFloat</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> LongWritable first;  </span><br><span class="line">    <span class="keyword">private</span> FloatWritable second;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LongAndFloat</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        set(<span class="keyword">new</span> LongWritable(),<span class="keyword">new</span> FloatWritable());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LongAndFloat</span><span class="params">(LongWritable l,FloatWritable f)</span></span>&#123;  </span><br><span class="line">        set(l,f);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">set</span><span class="params">(LongWritable longWritable, FloatWritable intWritable)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">        <span class="keyword">this</span>.first=longWritable;  </span><br><span class="line">        <span class="keyword">this</span>.second=intWritable;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> LongWritable <span class="title">getFirst</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> first;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> FloatWritable <span class="title">getSecond</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> second;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput arg0)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">        first.readFields(arg0);  </span><br><span class="line">        second.readFields(arg0);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput arg0)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">        first.write(arg0);  </span><br><span class="line">        second.write(arg0);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(LongAndFloat o)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">        <span class="keyword">int</span> cmp=first.compareTo(o.first);  </span><br><span class="line">        <span class="keyword">if</span>(cmp!=<span class="number">0</span>)&#123;  </span><br><span class="line">            <span class="keyword">return</span> cmp;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> second.compareTo(o.second);  </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="第二个MR："><a href="#第二个MR：" class="headerlink" title="第二个MR："></a>第二个MR：</h4><blockquote>
<p>输入数据为MR(1) 的输出，只是项目item的相似度，先不管用户ID，直接对后面的所有项目进行拆分。<br>输出应该类似下面：<br>Item_id1:Item_id2        次数<br>101,{107:1.0,106:2.0,105:2.0,104:4.0,103:4.0,102:3.0,101:5.0}<br>102,{106:1.0,105:1.0,104:2.0,103:3.0,102:3.0,101:3.0}  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WikiMapper2</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">VarLongWritable</span> ,<span class="title">VectorWritable</span>,<span class="title">IntWritable</span>,<span class="title">IntWritable</span>&gt;</span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(VarLongWritable userID,VectorWritable userVector,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>&#123;  </span><br><span class="line">        Iterator&lt;Vector.Element&gt; it=userVector.get().iterateNonZero();  </span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;  </span><br><span class="line">            <span class="keyword">int</span> index1=it.next().index();  </span><br><span class="line">    <span class="comment">//      System.out.println(&quot;index1:&quot;+index1);  </span></span><br><span class="line">            Iterator&lt;Vector.Element&gt; it2=userVector.get().iterateNonZero();  </span><br><span class="line">            <span class="keyword">while</span>(it2.hasNext())&#123;  </span><br><span class="line">                <span class="keyword">int</span> index2=it2.next().index();                    </span><br><span class="line">                <span class="comment">//  test  </span></span><br><span class="line">                <span class="comment">/*if(index1==101)&#123; </span></span><br><span class="line"><span class="comment">                    System.out.println(&quot;index1:&quot;+index1+&quot;,index2:&quot;+index2); </span></span><br><span class="line"><span class="comment">                &#125;*/</span>  </span><br><span class="line">                context.write(<span class="keyword">new</span> IntWritable(index1), <span class="keyword">new</span> IntWritable(index2));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WiKiReducer2</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">IntWritable</span>,<span class="title">IntWritable</span>,<span class="title">IntWritable</span>,<span class="title">VectorWritable</span>&gt; </span>&#123;        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(IntWritable itemIndex1,Iterable&lt;IntWritable&gt; itemPrefs,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>&#123;  </span><br><span class="line">            <span class="comment">// RandomAccessSparseVector(int cardinality, int initialCapacity)   </span></span><br><span class="line">            Vector itemVector=<span class="keyword">new</span> RandomAccessSparseVector(Integer.MAX_VALUE,<span class="number">10</span>);  </span><br><span class="line">            <span class="keyword">for</span>(IntWritable itemPref:itemPrefs)&#123;  </span><br><span class="line">                <span class="keyword">int</span> itemIndex2=itemPref.get();  </span><br><span class="line">                itemVector.set(itemIndex2, itemVector.get(itemIndex2)+<span class="number">1.0</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            context.write(itemIndex1, <span class="keyword">new</span> VectorWritable(itemVector));  </span><br><span class="line">    		<span class="comment">// System.out.println(itemIndex1+&quot;,&quot;+itemVector);  </span></span><br><span class="line">        &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="第三个MR："><a href="#第三个MR：" class="headerlink" title="第三个MR："></a>第三个MR：</h4><blockquote>
<p>含有两个Mapper，第一个MR(31)把MR(2)的输出的格式转为VectorOrPrefWritable;<br>MR2为用户评分矩阵<br>Item_id    user_id:preference<br>101,{107:1.0,106:2.0,105:2.0,104:4.0,103:4.0,102:3.0,101:5.0}<br>MR(32)针对MR(1)的输出把每一个项目ID和用户ID作为一对进行输出，输出格式也为VectorOrPrefWritable;<br>MR1生成物品同现矩阵<br>Item_id1:Item_id2        次数<br>userid:5,vector:{106:4.0,105:3.5,104:4.0,103:2.0,102:3.0,101:4.0}<br>VectorOrPrefWritable<br>input: MR2的输出userVectors<br>map: 输出：(itemId, VectorOrPrefWritable&lt;userId, pref&gt;)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WikiMapper31</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">IntWritable</span> ,<span class="title">VectorWritable</span>,<span class="title">IntWritable</span>,<span class="title">VectorOrPrefWritable</span>&gt;</span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(IntWritable key,VectorWritable value,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>&#123;  </span><br><span class="line">          </span><br><span class="line">                context.write(key, <span class="keyword">new</span> VectorOrPrefWritable(value.get()));  </span><br><span class="line">        <span class="comment">//      System.out.println(&quot;key&quot;+key.toString()+&quot;,vlaue&quot;+value.get());  </span></span><br><span class="line">            &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WiKiReducer31</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">IntWritable</span> ,<span class="title">VectorOrPrefWritable</span>,<span class="title">IntWritable</span>,<span class="title">VectorOrPrefWritable</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(IntWritable key,Iterable&lt;VectorOrPrefWritable&gt; values ,Context context )</span> <span class="keyword">throws</span> IOException, InterruptedException</span>&#123;            </span><br><span class="line">        <span class="keyword">for</span>(VectorOrPrefWritable va:values)&#123;  </span><br><span class="line">            context.write(key, va);          &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="第四个MR"><a href="#第四个MR" class="headerlink" title="第四个MR:"></a>第四个MR:</h4><blockquote>
<p>MR4的map不做任何事情；MR4的reduce输出就是把MR(31)和MR(32)的相同的itemID整合一下而已(注意此处的输入为两个路径)：如下：<br>101    {107:1.0,106:2.0,105:2.0,104:4.0,103:4.0,102:3.0,101:5.0} [5 1 4 2 3] [4.0 5.0 5.0 2.0 2.5]<br>101共现矩阵<br>101{107:1.0,106:2.0,105:2.0,104:4.0,103:4.0,102:3.0,101:5.0}<br>101用户评分矩阵<br>[5 1 4 2 3] [4.0 5.0 5.0 2.0 2.5]<br>Item_id    user_id:preference<br>101       2:2.0<br>101       5:4.0<br>101       4:5.0<br>101       3:2.0<br>101       1:5.0</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WikiMapper4</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">IntWritable</span> ,<span class="title">VectorOrPrefWritable</span>,<span class="title">IntWritable</span>,<span class="title">VectorOrPrefWritable</span>&gt; </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(IntWritable key,VectorOrPrefWritable value,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>&#123;  </span><br><span class="line">        context.write(key, value);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WiKiReducer4</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">IntWritable</span>,<span class="title">VectorOrPrefWritable</span>,<span class="title">IntWritable</span>,<span class="title">VectorAndPrefsWritable</span>&gt; </span>&#123;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(IntWritable key, Iterable&lt;VectorOrPrefWritable&gt; values,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>&#123;  </span><br><span class="line">            List&lt;Long&gt; userfs=<span class="keyword">new</span> ArrayList&lt;Long&gt;();  <span class="comment">//userID</span></span><br><span class="line">            List&lt;Float&gt; prefs=<span class="keyword">new</span> ArrayList&lt;Float&gt;();  <span class="comment">// pref</span></span><br><span class="line">            Vector v=<span class="keyword">null</span>;  </span><br><span class="line">            <span class="keyword">for</span>(VectorOrPrefWritable value:values)&#123;  </span><br><span class="line">                <span class="keyword">if</span>(value.getVector()!=<span class="keyword">null</span>)&#123;  </span><br><span class="line">                    v=value.getVector();  </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                    userfs.add(value.getUserID());  </span><br><span class="line">                    prefs.add(value.getValue());  </span><br><span class="line">                 &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            context.write(key, <span class="keyword">new</span> VectorAndPrefsWritable(v,userfs,prefs));  </span><br><span class="line">    <span class="comment">//System.out.println(&quot;key ,itemid:&quot;+key.toString()+&quot;, information:&quot;+v+&quot;,&quot;+userfs+&quot;,&quot;+prefs);  </span></span><br><span class="line">        &#125;   </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="第五个MR："><a href="#第五个MR：" class="headerlink" title="第五个MR："></a>第五个MR：</h4><blockquote>
<p>map:针对MR4的输出的每一行中的每一个用户，用这个用户的评分值(value)去乘以项目之间的相似度向量，比如针对第一条记录中的用户3，则有 Vectorforuser3=[1.0 2.0 2.0 4.0 4.0 3.0 5.0]* 2.5  则map的输出为 key : 3    value :  Vectorforuser3;<br>map的输出应该如下所示：<br>alluserids:[5, 1, 4, 2, 3]<br>,userid:5,vector:{107:4.0,106:8.0,105:8.0,104:16.0,103:16.0,102:12.0,101:20.0}<br>,userid:1,vector:{107:5.0,106:10.0,105:10.0,104:20.0,103:20.0,102:15.0,101:25.0}<br>,userid:4,vector:{107:5.0,106:10.0,105:10.0,104:20.0,103:20.0,102:15.0,101:25.0}<br>,userid:2,vector:{107:2.0,106:4.0,105:4.0,104:8.0,103:8.0,102:6.0,101:10.0}<br>,userid:3,vector:{107:2.5,106:5.0,105:5.0,104:10.0,103:10.0,102:7.5,101:12.5}  </p>
</blockquote>
<blockquote>
<p>Combine : 针对map的输出，把相同 key(即userID)的向量对应相加，得到的向量和即为该userID的对各个项目的评分；<br>combine的输出应该如下所示：<br>userid:1,vecotr:{107:5.0,106:18.0,105:15.5,104:33.5,103:39.0,102:31.5,101:44.0}<br>userid:2,vecotr:{107:4.0,106:20.5,105:15.5,104:36.0,103:41.5,102:32.5,101:45.5}<br>Reduce:针对combine的输出，把用户已经评价过分的项目筛选掉，然后按照评分值的大小有大到小排序输出，即为用户推荐项目；<br>最后的输出为：<br>1   [104:33.5,106:18.0,105:15.5,107:5.0]<br>2   [106:20.5,105:15.5,107:4.0]<br>3   [103:26.5,102:20.0,106:17.5]<br>4   [102:37.0,105:26.0,107:9.5]<br>5   [107:11.5]  </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WikiMapper5</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">IntWritable</span> ,<span class="title">VectorAndPrefsWritable</span>,<span class="title">VarLongWritable</span>,<span class="title">VectorWritable</span>&gt;</span>&#123;        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(IntWritable key,VectorAndPrefsWritable vectorAndPref,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>&#123;  </span><br><span class="line">        Vector coo=vectorAndPref.getVector();  </span><br><span class="line">        List&lt;Long&gt; userIds=vectorAndPref.getUserIDs();  </span><br><span class="line">        List&lt;Float&gt; prefValues=vectorAndPref.getValues();  </span><br><span class="line">        <span class="comment">//System.out.println(&quot;alluserids:&quot;+userIds);  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;userIds.size();i++)&#123;  </span><br><span class="line">            <span class="keyword">long</span> userID=userIds.get(i);  </span><br><span class="line">            <span class="keyword">float</span> prefValue=prefValues.get(i);  </span><br><span class="line">            Vector par=coo.times(prefValue);  </span><br><span class="line">            context.write(<span class="keyword">new</span> VarLongWritable(userID), <span class="keyword">new</span> VectorWritable(par));  </span><br><span class="line">            <span class="comment">//System.out.println(&quot;,userid:&quot;+userID+&quot;,vector:&quot;+par);  //  if the user id = 3 is the same as my paper then is right  </span></span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WiKiCombiner5</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">VarLongWritable</span>,<span class="title">VectorWritable</span>,<span class="title">VarLongWritable</span>,<span class="title">VectorWritable</span>&gt; </span>&#123;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(VarLongWritable key, Iterable&lt;VectorWritable&gt; values,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>&#123;  </span><br><span class="line">            Vector partial=<span class="keyword">null</span>;  </span><br><span class="line">            <span class="keyword">for</span>(VectorWritable v:values)&#123;  </span><br><span class="line">                partial=partial==<span class="keyword">null</span>?v.get():partial.plus(v.get());  </span><br><span class="line">            &#125;  </span><br><span class="line">            context.write(key, <span class="keyword">new</span> VectorWritable(partial));  </span><br><span class="line">            System.out.println(<span class="string">&quot;userid:&quot;</span>+key.toString()+<span class="string">&quot;,vecotr:&quot;</span>+partial);<span class="comment">//   here also should be the same as my paper&#x27;s result  </span></span><br><span class="line">        &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WiKiReducer5</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">VarLongWritable</span>,<span class="title">VectorWritable</span>,<span class="title">VarLongWritable</span>,<span class="title">RecommendedItemsWritable</span>&gt; </span>&#123;        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> recommendationsPerUser=RECOMMENDATIONSPERUSER;  </span><br><span class="line">    <span class="keyword">private</span> String path=JOB1OUTPATH;        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FastMap&lt;Integer,String&gt; map=<span class="keyword">new</span> FastMap&lt;Integer,String&gt;();  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(Context context)</span> <span class="keyword">throws</span> IOException</span>&#123;  </span><br><span class="line">        Configuration conf=<span class="keyword">new</span> Configuration();  </span><br><span class="line">        FileSystem fs=FileSystem.get(URI.create(path), conf);  </span><br><span class="line">        Path tempPath=<span class="keyword">new</span> Path(path);  </span><br><span class="line">        SequenceFile.Reader reader=<span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            reader=<span class="keyword">new</span> SequenceFile.Reader(fs, tempPath, conf);  </span><br><span class="line">            Writable key=(Writable)ReflectionUtils.newInstance(reader.getKeyClass(),conf);  </span><br><span class="line">            Writable value = (Writable) ReflectionUtils.newInstance(reader.getValueClass(), conf);   </span><br><span class="line">        <span class="comment">//  long position = reader.getPosition();    </span></span><br><span class="line">            <span class="keyword">while</span> (reader.next(key, value)) &#123;    </span><br><span class="line">                map.put(Integer.parseInt(key.toString()), value.toString());  </span><br><span class="line">        <span class="comment">//      System.out.println(key.toString()+&quot;,&quot;+value.toString());  </span></span><br><span class="line">            <span class="comment">//    position = reader.getPosition(); // beginning of next record    </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block  </span></span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(VarLongWritable key, Iterable&lt;VectorWritable&gt; values,Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>&#123;  </span><br><span class="line">          </span><br><span class="line">            <span class="keyword">int</span> userID=(<span class="keyword">int</span>)key.get();  </span><br><span class="line">            Vector rev=<span class="keyword">null</span>;  </span><br><span class="line">            <span class="keyword">for</span>(VectorWritable vec:values)&#123;  </span><br><span class="line">                rev=rev==<span class="keyword">null</span>? vec.get():rev.plus(vec.get());  </span><br><span class="line">            &#125;  </span><br><span class="line">            Queue&lt;RecommendedItem&gt;topItems=<span class="keyword">new</span> PriorityQueue&lt;RecommendedItem&gt;(  </span><br><span class="line">                    recommendationsPerUser+<span class="number">1</span>,  </span><br><span class="line">                    Collections.reverseOrder(ByValueRecommendedItemComparator.getInstance())  </span><br><span class="line">                    );  </span><br><span class="line">            Iterator&lt;Vector.Element&gt;recommendationVectorIterator=  </span><br><span class="line">                    rev.iterateNonZero();  </span><br><span class="line">            <span class="keyword">while</span>(recommendationVectorIterator.hasNext())&#123;  </span><br><span class="line">                Vector.Element e=recommendationVectorIterator.next();  </span><br><span class="line">                <span class="keyword">int</span> index=e.index();  </span><br><span class="line">                System.out.println(<span class="string">&quot;Vecotr.element.indxe:&quot;</span>+index);  <span class="comment">//  test here  find the index is item id or not  ** test result : index is item  </span></span><br><span class="line">                <span class="keyword">if</span>(!hasItem(userID,String.valueOf(index)))&#123;  </span><br><span class="line">                    <span class="keyword">float</span> value=(<span class="keyword">float</span>) e.get();  </span><br><span class="line">                    <span class="keyword">if</span>(topItems.size()&lt;recommendationsPerUser)&#123;  </span><br><span class="line">                        <span class="comment">//  here only set index  </span></span><br><span class="line">                        topItems.add(<span class="keyword">new</span> GenericRecommendedItem(index,value));  </span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value&gt;topItems.peek().getValue())&#123;  </span><br><span class="line">                        topItems.add(<span class="keyword">new</span> GenericRecommendedItem(index,value));  </span><br><span class="line">                        topItems.poll();  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            List&lt;RecommendedItem&gt;recom=<span class="keyword">new</span> ArrayList&lt;RecommendedItem&gt;(topItems.size());  </span><br><span class="line">            recom.addAll(topItems);  </span><br><span class="line">            Collections.sort(recom,ByValueRecommendedItemComparator.getInstance());  </span><br><span class="line">            context.write(key, <span class="keyword">new</span> RecommendedItemsWritable(recom));          </span><br><span class="line">        &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasItem</span><span class="params">(<span class="keyword">int</span> user,String item)</span></span>&#123;  <span class="comment">// to check whether the user has rate the item  </span></span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;  </span><br><span class="line">        String items=map.get(user);  </span><br><span class="line">        <span class="keyword">if</span>(items.contains(item))&#123;  </span><br><span class="line">            flag=<span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> flag;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.usherblog.site/2018/01/29/%E6%B5%85%E6%9E%90MapReduce%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Usher">
      <meta itemprop="description" content="Honor To The End">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Usher_Ou's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/29/%E6%B5%85%E6%9E%90MapReduce%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">浅析MapReduce(二）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">نُشر في</span>
      

      <time title="أُنشأ: 2018-01-29 19:23:56 / عُدل: 09:22:00" itemprop="dateCreated datePublished" datetime="2018-01-29T19:23:56+08:00">2018-01-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">في</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="浅析MapReduce（二）"><a href="#浅析MapReduce（二）" class="headerlink" title="浅析MapReduce（二）"></a>浅析MapReduce（二）</h1><h2 id="Map-gt-Reduce"><a href="#Map-gt-Reduce" class="headerlink" title="Map -&gt; Reduce"></a>Map -&gt; Reduce</h2><h3 id="Map阶段五大步骤"><a href="#Map阶段五大步骤" class="headerlink" title="Map阶段五大步骤"></a>Map阶段五大步骤</h3><p><img src="http://ov1nop9io.bkt.clouddn.com/121403128869360.png" alt="http://ov1nop9io.bkt.clouddn.com/121403128869360.png"></p>
<blockquote>
<p>MapReduce其实是分治算法的一种实现，所谓分治算法就是“就是分而治之”，将大的问题分解为相同类型的子问题（最好具有相同的规模），对子问题进行求解，然后合并成大问题的解。MapReduce就是分治法的一种，将输入进行分片，然后交给不同的task进行处理，然后合并成最终的解。具体流程图如下：</p>
</blockquote>
<p><img src="http://ov1nop9io.bkt.clouddn.com/20161228113443840.png" alt="http://ov1nop9io.bkt.clouddn.com/20161228113443840.png"></p>
<blockquote>
<p>MapReduce实际的处理过程可以理解为Input-&gt;Map-&gt;Sort-&gt;Combine-&gt;Partition-&gt;Reduce-&gt;Output。</p>
<p>（1）Input阶段 数据以一定的格式传递给Mapper，有TextInputFormat，DBInputFormat，SequenceFileFormat等可以使用，在Job.setInputFormat可以设置，也可以自定义分分片函数。</p>
<p> （2）Map阶段 对输入的key,value进行处理，即map(k1,v1) -&gt; list(k2,v2)，使用Job.setMapperClass进行设置。</p>
<p> （3） Sort阶段 对于Mapper的输出进行排序，使用Job.setOutputKeyComparatorClass进行设置，然后定义排序规则</p>
<p> （4） Combine阶段 这个阶段对于Sort之后有相同key的结果进行合并，使用Job.setCombinerClass进行设置，也可以自定义Combine Class类。</p>
<p>（5） Partition阶段 将Mapper的中间结果按照Key的范围划分为R份（Reduce作业的个数），默认使用HashPatitioner（key.hashCode() &amp; Integer.MAX_VALUE) % numPartitions），也可以自定义划分的函数。使用Job.setPartitionClass进行设置。</p>
<p>（6） Reduce阶段 对于Mapper的结果进一步进行处理，Job.setReducerClass进行设置自定义的Reduce类。</p>
<p>（7） Output阶段 Reducer输出数据的格式。</p>
</blockquote>
<blockquote>
<p>   MapReduce将作业的整个运行过程分为两个阶段：Map阶段和Reduce阶段<br>    Map阶段由一定数量的Map Task组成<br>        输入数据格式解析：InputFormat<br>        输入数据处理：Mapper<br>        数据分组：Partitioner<br>   Reduce阶段由一定数量的Reduce Task组成<br>        数据远程拷贝<br>        数据按照key排序<br>        数据处理：Reducer<br>        数据输出格式：OutputFormat</p>
</blockquote>
<h3 id="InputFormat"><a href="#InputFormat" class="headerlink" title="InputFormat"></a>InputFormat</h3><blockquote>
<p> InputFormat 负责处理MR的输入部分.<br>      有三个作用:<br>     1验证作业的输入是否规范.<br>     2把输入文件切分成InputSplit. (处理跨行问题)<br>     3提供RecordReader 的实现类，把InputSplit读到Mapper中进行处理.</p>
</blockquote>
<h3 id="TextInputFormat"><a href="#TextInputFormat" class="headerlink" title="TextInputFormat"></a>TextInputFormat</h3><blockquote>
<p>1.TextInputformat是默认的处理类，处理普通文本文件。<br>2.文件中每一行作为一个记录，他将每一行在文件中的起始偏移量作为key，每一行的内容作为value。<br>3.默认以\n或回车键作为一行记录。<br>4.TextInputFormat继承了FileInputFormat。</p>
</blockquote>
<h3 id="combiner"><a href="#combiner" class="headerlink" title="combiner"></a>combiner</h3><h4 id="combiner的出现-为什么需要Map规约操作"><a href="#combiner的出现-为什么需要Map规约操作" class="headerlink" title="combiner的出现-为什么需要Map规约操作"></a>combiner的出现-为什么需要Map规约操作</h4><p><img src="http://ov1nop9io.bkt.clouddn.com/%E5%9B%BE%E7%89%878.png" alt="http://ov1nop9io.bkt.clouddn.com/%E5%9B%BE%E7%89%878.png"></p>
<blockquote>
<p>在上述过程中，我们看到至少两个性能瓶颈：</p>
<p>（1）如果我们有10亿个数据，Mapper会生成10亿个键值对在网络间进行传输，但如果我们只是对数据求最大值，那么很明显的Mapper只需要输出它所知道的最大值即可。这样做不仅可以减轻网络压力，同样也可以大幅度提高程序效率。</p>
<p>　　总结：网络带宽严重被占降低程序效率；</p>
</blockquote>
<blockquote>
<p>在MapReduce编程模型中，在Mapper和Reducer之间有一个非常重要的组件，它解决了上述的性能瓶颈问题，它就是Combiner。</p>
</blockquote>
<p><img src="http://ov1nop9io.bkt.clouddn.com/20161227175120887.gif" alt="http://ov1nop9io.bkt.clouddn.com/20161227175120887.gif"></p>
<blockquote>
<p>①与mapper和reducer不同的是，combiner没有默认的实现，需要显式的设置在conf中才有作用。</p>
<p>②并不是所有的job都适用combiner，只有操作满足结合律的才可设置combiner。</p>
<p>combine操作类似于：opt(opt(1, 2, 3), opt(4, 5, 6))。如果opt为求和、求最大值的话，可以使用，但是如果是求中值的话，不适用。</p>
<p>每一个map都可能会产生大量的本地输出，Combiner的作用就是对map端的输出先做一次合并，以减少在map和reduce节点之间的数据传输量，以提高网络IO性能</p>
</blockquote>
<h4 id="Combiner的作用"><a href="#Combiner的作用" class="headerlink" title="Combiner的作用"></a>Combiner的作用</h4><blockquote>
<p>(1）Combiner最基本是实现<strong>本地key的聚合，对map输出的key排序，value进行迭代</strong>。如下所示：</p>
<p>​    map: (K1, V1) → list(K2, V2) </p>
<p>​    combine: (K2, list(V2)) → list(K2, V2) </p>
<p>​    reduce: (K2, list(V2)) → list(K3, V3)</p>
<p>（2）Combiner还有<strong>本地reduce</strong>功能（其本质上就是一个reduce），例如Hadoop自带的wordcount的例子和找出value的最大值的程序，combiner和reduce完全一致，如下所示：</p>
<p>　　map: (K1, V1) → list(K2, V2)<br>　　combine: (K2, list(V2)) → list(K3, V3)<br>　　reduce: (K3, list(V3)) → list(K4, V4)</p>
<p>使用combiner之后，先完成的map会在本地聚合，提升速度。对于hadoop自带的wordcount的例子，value就是一个叠加的数字，所以map一结束就可以进行reduce的value叠加，而不必要等到所有的map结束再去进行reduce的value叠加。</p>
</blockquote>
<h4 id="融合Combiner的MapReduce"><a href="#融合Combiner的MapReduce" class="headerlink" title="融合Combiner的MapReduce"></a>融合Combiner的MapReduce</h4><p><img src="http://ov1nop9io.bkt.clouddn.com/%E5%9B%BE%E7%89%8789.png" alt="http://ov1nop9io.bkt.clouddn.com/%E5%9B%BE%E7%89%8789.png"></p>
<h4 id="使用MyReducer作为Combiner"><a href="#使用MyReducer作为Combiner" class="headerlink" title="使用MyReducer作为Combiner"></a>使用MyReducer作为Combiner</h4><blockquote>
<p>// 设置Map规约Combiner<br>    job.setCombinerClass(MyReducer.class);</p>
</blockquote>
<p>执行后看到map的输出和combine的输入统计是一致的，而combine的输出与reduce的输入统计是一样的。<br>由此可以看出规约操作成功，而且执行在map的最后，reduce之前。</p>
<h4 id="自己定义Combiner"><a href="#自己定义Combiner" class="headerlink" title="自己定义Combiner"></a>自己定义Combiner</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCombiner</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">        <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">LongWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            Text key,</span></span></span><br><span class="line"><span class="params"><span class="function">            java.lang.Iterable&lt;LongWritable&gt; values,</span></span></span><br><span class="line"><span class="params"><span class="function">            org.apache.hadoop.mapreduce.Reducer&lt;Text, LongWritable, Text, LongWritable&gt;.Context context)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> java.io.IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 显示次数表示规约函数被调用了多少次，表示k2有多少个分组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Combiner输入分组&lt;&quot;</span> + key.toString() + <span class="string">&quot;,N(N&gt;=1)&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> count = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (LongWritable value : values) &#123;</span><br><span class="line">            count += value.get();</span><br><span class="line">            <span class="comment">// 显示次数表示输入的k2,v2的键值对数量</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Combiner输入键值对&lt;&quot;</span> + key.toString() + <span class="string">&quot;,&quot;</span></span><br><span class="line">                    + value.get() + <span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        context.write(key, <span class="keyword">new</span> LongWritable(count));</span><br><span class="line">        <span class="comment">// 显示次数表示输出的k2,v2的键值对数量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Combiner输出键值对&lt;&quot;</span> + key.toString() + <span class="string">&quot;,&quot;</span> + count</span><br><span class="line">                + <span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle"></a>shuffle</h2><h3 id="Reduce阶段三个步骤"><a href="#Reduce阶段三个步骤" class="headerlink" title="Reduce阶段三个步骤"></a>Reduce阶段三个步骤</h3><p><img src="http://ov1nop9io.bkt.clouddn.com/%E5%9B%BE%E7%89%87562.png" alt="http://ov1nop9io.bkt.clouddn.com/%E5%9B%BE%E7%89%87562.png"></p>
<blockquote>
<p>Step2.1就是一个Shuffle[随机、洗牌]操作</p>
</blockquote>
<p><img src="http://ov1nop9io.bkt.clouddn.com/20161228102308185.png" alt="http://ov1nop9io.bkt.clouddn.com/20161228102308185.png"></p>
<blockquote>
<p>系统执行排序的过程(即将map输出作为输入传给reduce)，称为shuffle.即这张图是官方对Shuffle过程的描述，hadoop的核心思想是MapReduce，但shuffle又是MapReduce的核心(心脏)。shuffle的主要工作是从Map结束到Reduce开始之间的过程。首先看下这张图，就能了解shuffle所处的位置。图中的partitions、copy phase、sort phase所代表的就是shuffle的不同阶段(大致范围)。也可以这样理解， Shuffle描述着数据从map task输出到reduce task输入的这段过程。</p>
<p> map 端的Shuffle细节：<br> \1. 在map task执行时，它的输入数据来源于HDFS的block。(map函数产生输出时，利用缓冲的方式写入内存，并出于效率考虑的方式就行预排序。如上图。此处默认的内存大小为100M,可通过io.sort.mr 来设置，当此缓冲区编程 %80的时候 ，一个后台线程就会将内容写入磁盘。在写入磁盘之前，线程首先根据最终要传的reduce把这些数据划分成相应的分区(partition),在每个分区中，后台线程进行内排序，如果有combine，就会在排序后的分区内执行。)</p>
<ol>
<li><p>在经过mapper的运行后，我们得知mapper的输出是这样一个key/value对：相同的key 到底应该交由哪个reduce去做，是现在决定的，也就是partition 作用。MapReduce提供Partitioner接口，它的作用就是根据key或value及reduce的数量来决定当前的这对输出数据最终应该交由哪个reduce task处理。默认对key hash后再以reduce task数量取模。默认的取模方式只是为了平均reduce的处理能力，如果用户自己对Partitioner有需求，可以订制并设置到job上。</p>
</li>
<li><p>接下来，需要将数据写入内存缓冲区中，缓冲区的作用是批量收集map结果，减少磁盘IO的影响。key/value对以及Partition的结果都会被写入缓冲区，当然写入之前，key与value值都会被序列化成字节数组。</p>
</li>
<li><p>reduce task在执行之前的工作就是不断地拉取当前job里每个map task的最终结果，然后对从不同地方拉取过来的数据不断地做merge(合并），也最终形成一个文件作为reduce task的输入文件</p>
<p>​</p>
<p>reduce 端的Shuffle细节：Copy过程，简单地拉取数据。reduce 通过http的方式得到输出文件的分区。Merge阶段reduce task在执行之前的工作就是不断地拉取当前job里每个map task的最终结果，然后对从不同地方拉取过来的数据不断地做merge(合并），也最终形成一个文件作为reduce task的输入文件。</p>
<p>​</p>
</li>
</ol>
</blockquote>
<h3 id="partitioner"><a href="#partitioner" class="headerlink" title="partitioner"></a>partitioner</h3><h4 id="Hadoop内置Partitioner"><a href="#Hadoop内置Partitioner" class="headerlink" title="Hadoop内置Partitioner"></a>Hadoop内置Partitioner</h4><blockquote>
<p>MapReduce的使用者通常会指定Reduce任务和Reduce任务输出文件的数量（R）。</p>
<p>用户在中间key上使用分区函数来对数据进行分区，之后在输入到后续任务执行进程。一个默认的分区函数式使用hash方法（比如常见的：hash(key) mod R）进行分区。hash方法能够产生非常平衡的分区。Hadoop中自带了一个默认的分区类HashPartitioner，</p>
<p>它继承了Partitioner类，提供了一个getPartition的方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Partition keys by their &#123;<span class="doctag">@link</span> Object#hashCode()&#125;. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashPartitioner</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Partitioner</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/** Use &#123;<span class="doctag">@link</span> Object#hashCode()&#125; to partition. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(K key, V value,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> numReduceTasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (key.hashCode() &amp; Integer.MAX_VALUE) % numReduceTasks;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>Map的结果，会通过partition分发到Reducer上，Reducer做完Reduce操作后，通过OutputFormat，进行输出.partition是分割map每个节点的结果，按照key分别映射给不同的reduce，也是可以自定义的。这里其实可以理解归类。</p>
<p>Mapper的结果，可能送到Combiner做合并，Combiner在系统中并没有自己的基类，而是用Reducer作为Combiner的基类，他们对外的功能是一样的，只是使用的位置和使用时的上下文不太一样而已。Mapper最终处理的键值对</p>
</blockquote>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><blockquote>
<ol>
<li>Partitioner决定了Map Task输出的每条数据交给哪个Reduce Task处理</li>
<li>默认实现：HashPartitioner是mapreduce的默认partitioner。计算方法是 reducer=(key.hashCode() &amp; Integer.MAX_VALUE) % numReduceTasks，得到当前的目的reducer。(hash(key) mod R 其中R是Reduce Task数目)</li>
<li>允许用户自定义 很多情况需自定义Partitioner比如“hash(hostname(URL)) mod R”确保相同域名的网页交给同一个Reduce Task处理</li>
</ol>
</blockquote>
<h3 id="自定义partitioner"><a href="#自定义partitioner" class="headerlink" title="自定义partitioner"></a>自定义partitioner</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 自定义Partitioner类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">KpiPartitioner</span> <span class="keyword">extends</span> <span class="title">Partitioner</span>&lt;<span class="title">Text</span>, <span class="title">KpiWritable</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(Text key, KpiWritable value, <span class="keyword">int</span> numPartitions)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 实现不同的长度不同的号码分配到不同的reduce task中</span></span><br><span class="line">            <span class="keyword">int</span> numLength = key.toString().length();</span><br><span class="line">            <span class="keyword">if</span> (numLength == <span class="number">11</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">设置为打包运行，设置Partitioner为LiuPartitioner设置ReducerTask的个数为2</span></span><br><span class="line"><span class="comment">注意：分区的例子必须要设置为打成jar包运行！*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 定义一个作业</span></span><br><span class="line">        Job job = <span class="keyword">new</span> Job(getConf(), <span class="string">&quot;MyJob&quot;</span>);</span><br><span class="line">        <span class="comment">// 分区需要设置为打包运行</span></span><br><span class="line">        job.setJarByClass(MyLiuJob.class);</span><br><span class="line">        <span class="comment">// 设置输入目录</span></span><br><span class="line">        FileInputFormat.setInputPaths(job, <span class="keyword">new</span> Path(INPUT_PATH));</span><br><span class="line">        <span class="comment">// 设置自定义Mapper类</span></span><br><span class="line">        job.setMapperClass(MyMapper.class);</span><br><span class="line">        <span class="comment">// 指定&lt;k2,v2&gt;的类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(KpiWritable.class);</span><br><span class="line">        <span class="comment">// 设置Partitioner</span></span><br><span class="line">        job.setPartitionerClass(LiuPartitioner.class);</span><br><span class="line">        job.setNumReduceTasks(<span class="number">2</span>);</span><br><span class="line">         <span class="comment">// 设置自定义Reducer类</span></span><br><span class="line">        job.setReducerClass(MyReducer.class);</span><br><span class="line">        <span class="comment">// 指定&lt;k3,v3&gt;的类型</span></span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputKeyClass(KpiWritable.class);</span><br><span class="line">        <span class="comment">// 设置输出目录</span></span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(OUTPUT_PATH));</span><br><span class="line">        <span class="comment">// 提交作业</span></span><br><span class="line">        System.exit(job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="MapReduce排序分组"><a href="#MapReduce排序分组" class="headerlink" title="MapReduce排序分组"></a>MapReduce排序分组</h2><p><img src="http://ov1nop9io.bkt.clouddn.com/121403128869360.png" alt="http://ov1nop9io.bkt.clouddn.com/121403128869360.png"></p>
<blockquote>
<p>Step1.4第四步中需要对不同分区中的数据进行排序和分组，默认情况按照key进行排序和分组</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.usherblog.site/2018/01/27/%E6%B5%85%E6%9E%90MapReduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Usher">
      <meta itemprop="description" content="Honor To The End">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Usher_Ou's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/27/%E6%B5%85%E6%9E%90MapReduce/" class="post-title-link" itemprop="url">浅析MapReduce</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">نُشر في</span>
      

      <time title="أُنشأ: 2018-01-27 19:23:56 / عُدل: 23:05:55" itemprop="dateCreated datePublished" datetime="2018-01-27T19:23:56+08:00">2018-01-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">في</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="浅析MapReduce"><a href="#浅析MapReduce" class="headerlink" title="浅析MapReduce"></a>浅析MapReduce</h1><h2 id="MapReduce概念"><a href="#MapReduce概念" class="headerlink" title="MapReduce概念"></a>MapReduce概念</h2><blockquote>
<p>Mapreduce 是一个分布式运算程序的编程框架，是用户开发“基于 hadoop 的数据分析 应用”的核心框架<br>Mapreduce 核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的 分布式运算程序，并发运行在一个 hadoop 集群上</p>
</blockquote>
<h3 id="map-映射"><a href="#map-映射" class="headerlink" title="map(映射)"></a>map(映射)</h3><blockquote>
<p>“Map”:主结点读入输入数据，把它分成可以用相同方法解决的小数据块（这里是一个分而治之的思想），然后把这些小数据块分发到不同的工作节点上(worder nodes)上，每一个工作节点(worder node)循环做同样的事，这就行成了一个树行结构（分布式计算中的很多模型都和图论有关，pageRank也是），而每一个叶子节点有来处理每一个具体的小数据块，再把这些处理结果返回给父节点。</p>
</blockquote>
<h3 id="reduce-归约"><a href="#reduce-归约" class="headerlink" title="reduce(归约)"></a>reduce(归约)</h3><blockquote>
<p>“Reduce”:主结节得到所有子节点的处理结果，然后把所有结果组合并且返回到输出。</p>
</blockquote>
<h2 id="MapReduce原理"><a href="#MapReduce原理" class="headerlink" title="MapReduce原理"></a>MapReduce原理</h2><h3 id="MapReduce执行流程"><a href="#MapReduce执行流程" class="headerlink" title="MapReduce执行流程"></a>MapReduce执行流程</h3><blockquote>
<p>（1） 一个 mr 程序启动的时候，最先启动的是 MRAppMaster， MRAppMaster 启动后根据本次 job 的描述信息，计算出需要的 maptask 实例数量，然后向集群申请机器启动相应数量的 maptask 进程<br>（2） maptask 进程启动之后，根据给定的数据切片(哪个文件的哪个偏移量范围)范围进行数 据处理，主体流程为：<br>​    A、 利用客户指定的 inputformat 来获取 RecordReader 读取数据，形成输入 KV 对<br>​    B、 将输入 KV 对传递给客户定义的 map()方法，做逻辑运算，并将 map()方法输出的 KV 对收 集到缓存<br>​    C、 将缓存中的 KV 对按照 K 分区排序后不断溢写到磁盘文件 （超过缓存内存写到磁盘临时文件，最后都写到该文件，ruduce 获取该文件后，删除 ）<br>（3） MRAppMaster 监控到所有 maptask 进程任务完成之后（真实情况是，某些 maptask 进 程处理完成后，就会开始启动 reducetask 去已完成的 maptask 处 fetch 数据），会根据客户指 定的参数启动相应数量的 reducetask 进程，并告知 reducetask 进程要处理的数据范围（数据<br>分区）<br>（4） Reducetask 进程启动之后，根据 MRAppMaster 告知的待处理数据所在位置，从若干台 maptask 运行所在机器上获取到若干个 maptask 输出结果文件，并在本地进行重新归并排序， 然后按照相同 key 的 KV 为一个组，调用客户定义的 reduce()方法进行逻辑运算，并收集运<br>算输出的结果 KV，然后调用客户指定的 outputformat 将结果数据输出到外部存储</p>
</blockquote>
<p><img src="http://ov1nop9io.bkt.clouddn.com/%E5%9B%BE%E7%89%871.png" alt="http://ov1nop9io.bkt.clouddn.com/%E5%9B%BE%E7%89%871.png"></p>
<h3 id="MRjob的运行分析"><a href="#MRjob的运行分析" class="headerlink" title="MRjob的运行分析"></a>MRjob的运行分析</h3><blockquote>
<p>1、client提交mr job</p>
<p>2、rm协调资源分配</p>
<p>3、nm启动并监控container</p>
<p>4、appmaster协调task</p>
<p>5、appmaster和task均由rm调度、由nm管理</p>
<p>6、hdfs用于在其他entity间共享job文件</p>
</blockquote>
<h3 id="MapReduce原理图"><a href="#MapReduce原理图" class="headerlink" title="MapReduce原理图"></a>MapReduce原理图</h3><p><img src="http://ov1nop9io.bkt.clouddn.com/%E5%9B%BE%E7%89%872.png" alt="http://ov1nop9io.bkt.clouddn.com/%E5%9B%BE%E7%89%872.png"></p>
<p><a href=""><img src="http://ov1nop9io.bkt.clouddn.com/%E5%9B%BE%E7%89%873.png" alt="http://ov1nop9io.bkt.clouddn.com/%E5%9B%BE%E7%89%873.png"></a></p>
<h4 id="job提交"><a href="#job提交" class="headerlink" title="job提交"></a>job提交</h4><blockquote>
<p>submit()方法内部创建submitter并调用submitJobInternal()</p>
<p>submit过程如下：</p>
<p>请求rm获取appid，用做mr jobid</p>
<p>检查output的有效性</p>
<p>计算inputsplit</p>
<p>复制资源(jar、conf、inputsplit)到hdfs中，存放在以jobid命名的目录下</p>
<p>jar文件在集群上有更多的副本，以备nm使用</p>
<p>rm.submitApplication()</p>
</blockquote>
<h4 id="job初始化"><a href="#job初始化" class="headerlink" title="job初始化"></a>job初始化</h4><blockquote>
<p>rm收到submitApp()后将请求转给Yarnscheduler</p>
<p>scheduler分配container</p>
<p>rm在该container启动appmaster , 并交由nm管理。</p>
<p>appmaster创建多个记录对象跟踪job进度，它将接受task的进度或完成报告。</p>
<p>检索inputsplit</p>
<p>为每个split创建map任务和一定数量的reduce任务(setNumRed..())，此时分配jobid</p>
<p>appmaster判断如何运行task，如果是小job，appmaster会在同一jvm中运行</p>
<p>uber task就是指这一点，因为开启新容器分配和运行程序更耗费资源。</p>
<p>小job的衡量标准是map&lt;10，只有reduce=1，而且inputsize &lt; blocksize。这些值可以修改。</p>
<p>​     mapreduce.job.ubertask.maxmaps</p>
<p>​     mapreduce.job.ubertask.maxreduces</p>
<p>​     mapreduce.job.ubertask.enable</p>
<p>最后，Appmaster调用OutputCommitter的setupJob()方法，默认是FileOutputCommimter，主要是创建output目录和临时工作目录</p>
</blockquote>
<h4 id="task资源指派"><a href="#task资源指派" class="headerlink" title="task资源指派"></a>task资源指派</h4><blockquote>
<p>如果job没有指定为uber task，app<br>master从rm处为所有m和r任务请求容器。先发起map请求，优先级高于reduce，因为所有map都要在reduce的sort阶段启动前完成。对reduce的请求只有在5%的map任务完成后才会发起。</p>
<p>reduce可运行在任何节点，而map请求有调度器努力维护的数据本地约束。因此会尽量保证maptask是datalocal，但是也存在racklocal和rackoff的情况。对于特定的job，可通过查看job的计数器决定本地级别运行的task数据。</p>
<p>请求也可指定对内存和CPU的要求，默认每个m&amp;r分配1024m内存和1个虚拟core，但可通过以下属性进行修改。mapreduce.map.memory.mb, mapreduce.reduce.memory.mb, mapreduce.map.cpu.vcores mapreduce.reduce.cpu.vcores.</p>
<p>一旦sler为task指定了特定node的资源，app master会联络nm来启动container。该任务就会由YarnChild的java程序执行，该类会对所需资源进行本地化，比如conf、jar、缓存等，最终运行m或者r。该类运行在专有的jvm中，因此不会影响nm。</p>
<p>每个task都会执行setup和commit动作。他们和task在同一jvm中。如果是File-based的job，commit动作会将out从临时目录移动到最终目录。commit协议会确保在启用了机智运行时，重复的task只要有一个提交，其他都会终止掉。</p>
</blockquote>
<h3 id="streaming"><a href="#streaming" class="headerlink" title="streaming"></a>streaming</h3><p><img src="http://ov1nop9io.bkt.clouddn.com/%E5%9B%BE%E7%89%874.png" alt="http://ov1nop9io.bkt.clouddn.com/%E5%9B%BE%E7%89%874.png"></p>
<blockquote>
<p>流方式会运行特定的mr任务目的在于启动用户提供的可执行程序并与之通信。</p>
<p>流task使用标准io流和进程通信。执行期间java程序传递input k-v对给外部进程，在外部进程中执行用户定义的mr函数，执行后将output kv对回传给java进程。从NM角度看，就如同运行mr程序的子进程。</p>
</blockquote>
<h3 id="进度状态更新"><a href="#进度状态更新" class="headerlink" title="进度状态更新"></a>进度状态更新</h3><p><img src="http://ov1nop9io.bkt.clouddn.com/%E5%9B%BE%E7%89%875.png" alt="http://ov1nop9io.bkt.clouddn.com/%E5%9B%BE%E7%89%875.png"></p>
<blockquote>
<p>job和每个task都有status信息，其中包括state（running、successful complete、failure）、m&amp;r的progress、job计数器、消息和描述等信息。</p>
<p>task执行时，会跟踪自己的progress。对于map任务来说，是input被处理的比例。对于reduce，稍复杂，但系统仍可估算处理的</p>
<p>input 比例，通过将总progress分成3个阶段（copy、sort、reduce），每个阶段各1/3。因此如果一个task运行了一半的reduce，那么他的progress计算如下：</p>
<p>​      1/3(copy) + 1/3(sort) +1/3(reduce)x1/2=5/6 </p>
</blockquote>
<h3 id="job的完成"><a href="#job的完成" class="headerlink" title="job的完成"></a>job的完成</h3><blockquote>
<p>App master在收到job最后一个task完成通知后，会修改job的状态为”successful”，job轮询时就会感知到job已成功完成，因此会打印消息给user并从waitForComplete()方法返回。此时job的统计信息和计数器会打印在console中。<br>可以让app master发送通知给client，让其进行回调处理。mapreduce.job.endnotification.url<br>最后，job完成时，app master和task container会删除状态信息。调用OutputCommitter.commitJob()方法。job信息有job historyserver归档供以后使用。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.usherblog.site/2018/01/24/Hadoop%20HDFS%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Usher">
      <meta itemprop="description" content="Honor To The End">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Usher_Ou's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/24/Hadoop%20HDFS%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Hadoop HDFS原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">نُشر في</span>
      

      <time title="أُنشأ: 2018-01-24 19:23:56 / عُدل: 19:30:54" itemprop="dateCreated datePublished" datetime="2018-01-24T19:23:56+08:00">2018-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">في</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Hadoop-HDFS原理"><a href="#Hadoop-HDFS原理" class="headerlink" title="Hadoop HDFS原理"></a>Hadoop HDFS原理</h1><h2 id="HDFS-架构"><a href="#HDFS-架构" class="headerlink" title="HDFS 架构"></a>HDFS 架构</h2><p><img src="http://ov1nop9io.bkt.clouddn.com/hdfs-architecture.png" alt="http://ov1nop9io.bkt.clouddn.com/hdfs-architecture.png"></p>
<h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><blockquote>
<p>  对外部客户机而言，HDFS就像一个传统的分级文件系统。可以创建、删除、移动或重命名文件，等等。但是 HDFS 的架构是基于一组特定的节点构建的，这是由它自身的特点决定的。这些节点包括 NameNode（仅一个），它在 HDFS 内部提供元数据服务；DataNode，它为 HDFS 提供存储块。由于仅存在一个 NameNode，因此这是 HDFS 的一个缺点（单点失败）。</p>
<p>  存储在 HDFS 中的文件被分成块，然后将这些块复制到多个计算机中（DataNode）。这与传统的 RAID 架构大不相同。块的大小（通常为 64MB）和复制的块数量在创建文件时由客户机决定。NameNode 可以控制所有文件操作。HDFS 内部的所有通信都基于标准的 TCP/IP 协议。</p>
<p>  HDFS和现有的分布式文件系统有很多共同点。但同时，它和其他的分布式文件系统的区别也是很明显的。HDFS是一个高度容错性的系统，适合部署在廉价的机器上。HDFS能提供高吞吐量的数据访问，非常适合大规模数据集上的应用。HDFS放宽了一部分POSIX约束，来实现流式读取文件系统数据的目的。HDFS在最开始是作为Apache Nutch搜索引擎项目的基础架构而开发的。HDFS是Apache Hadoop Core项目的一部分。</p>
</blockquote>
<h3 id="NameNode"><a href="#NameNode" class="headerlink" title="NameNode"></a>NameNode</h3><blockquote>
<p>存储文件的metadata，运行时所有数据都保存到内存，整个HDFS可存储的文件数受限于NameNode的内存大小</p>
<p>一个Block在NameNode中对应一条记录（一般一个block占用150字节），如果是大量的小文件，会消耗大量内存。同时map task的数量是由splits来决定的，所以用MapReduce处理大量的小文件时，就会产生过多的map task，线程管理开销将会增加作业时间。处理大量小文件的速度远远小于处理同等大小的大文件的速度。因此Hadoop建议存储大文件</p>
<p>数据会定时保存到本地磁盘，但不保存block的位置信息，而是由DataNode注册时上报和运行时维护（NameNode中与DataNode相关的信息并不保存到NameNode的文件系统中，而是NameNode每次重启后，动态重建）</p>
<p>NameNode失效则整个HDFS都失效了，所以要保证NameNode的可用性</p>
</blockquote>
<h3 id="Secondary-NameNode"><a href="#Secondary-NameNode" class="headerlink" title="Secondary NameNode"></a>Secondary NameNode</h3><blockquote>
<p>定时与NameNode进行同步（定期合并文件系统镜像和编辑，然后把合并后的传给NameNode，替换其镜像，并清空编辑日志，类似于CheckPoint机制），但NameNode失效后仍需要手工将其设置成主机</p>
</blockquote>
<h3 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h3><blockquote>
<p>DataNode 也是一个通常在 HDFS实例中的单独机器上运行的软件。Hadoop 集群包含一个 NameNode 和大量 DataNode。DataNode通常以机架的形式组织，机架通过一个交换机将所有系统连接起来。Hadoop 的一个假设是：机架内部节点之间的传输速度快于机架间节点的传输速度。</p>
<p>  DataNode 响应来自 HDFS 客户机的读写请求。它们还响应来自 NameNode 的创建、删除和复制块的命令。NameNode 依赖来自每个 DataNode 的定期心跳（heartbeat）消息。每条消息都包含一个块报告，NameNode 可以根据这个报告验证块映射和其他文件系统元数据。如果 DataNode 不能发送心跳消息，NameNode 将采取修复措施，重新复制在该节点上丢失的块。</p>
<p>即保存具体的block数据</p>
<p>负责数据的读写操作和复制操作</p>
<p>DataNode启动时会向NameNode报告当前存储的数据块信息，后续也会定时报告修改信息</p>
<p>DataNode之间会进行通信，复制数据块，保证数据的冗余性</p>
</blockquote>
<h3 id="HDFSWriteOperation"><a href="#HDFSWriteOperation" class="headerlink" title="HDFSWriteOperation"></a>HDFSWriteOperation</h3><p><img src="http://ov1nop9io.bkt.clouddn.com/63503acbjw1f5w48p90chj20k20bzdgr.jpg" alt="http://ov1nop9io.bkt.clouddn.com/63503acbjw1f5w48p90chj20k20bzdgr.jpg"></p>
<blockquote>
<p>  在分布式文件系统中，需要确保数据的一致性。对于HDFS来说，直到所有要保存数据的DataNodes确认它们都有文件的副本时，数据才被认为写入完成。因此，数据一致性是在写的阶段完成的。一个客户端无论选择从哪个DataNode读取，都将得到相同的数据。</p>
<p>  1.客户端将文件写入本地磁盘的N#x4E34;时文件中</p>
<p>  2.当临时文件大小达到一个block大小时，HDFS client通知NameNode，申请写入文件</p>
<p>  3.NameNode在HDFS的文件系统中创建一个文件，并把该block id和要写入的DataNode的列表返回给客户端</p>
<p>  4.客户端收到这些信息后，将临时文件写入DataNodes</p>
<ul>
<li>4.1 客户端将文件内容写入第一个DataNode（一般以4kb为单位进行传输）</li>
<li>4.2 第一个DataNode接收后，将数据写入本地磁盘，同时也传输给第二个DataNode</li>
<li>4.3 依此类推到最后一个DataNode，数据在DataNode之间是通过pipeline的方式进行复制的</li>
<li>4.4 后面的DataNode接收完数据后，都会发送一个确认给前一个DataNode，最终第一个DataNode返回确认给客户端</li>
<li>4.5 当客户端接收到整个block的确认后，会向NameNode发送一个最终的确认信息</li>
<li>4.6 如果写入某个DataNode失败，数据会继续写入其他的DataNode。然后NameNode会找另外一个好的DataNode继续复制，以保证冗余性</li>
<li>4.7 每个block都会有一个校验码，并存放到独立的文件中，以便读的时候来验证其完整性</li>
</ul>
<p>  5.文件写完后（客户端关闭），NameNode提交文件（这时文件才可见，֘#x5982;果提交前，NameNode垮掉，那文件也就丢失了。fsync：只保证数据的信息写到NameNode上，但并不保证数据已经被写到DataNode中）</p>
<p>  <strong>Rack aware（机架感知）</strong></p>
<p>  通过配置文件指定机架名和DNS的对应关系</p>
<p>  假设复制参数是3，在写入文件时，会在本地的机架保存一份数据，然后在另外一个机架内保存两份数据（同机架内的传输速度快，从而提高性能）</p>
<p>  整个HDFS的集群，最好是负载平衡的，这样才能尽量利用集群的优势</p>
</blockquote>
<h3 id="HDFSReadOperation"><a href="#HDFSReadOperation" class="headerlink" title="HDFSReadOperation"></a>HDFSReadOperation</h3><p><img src="http://ov1nop9io.bkt.clouddn.com/63503acbjw1f5w48ovukqj20jm0ermy3.jpg" alt="http://ov1nop9io.bkt.clouddn.com/63503acbjw1f5w48ovukqj20jm0ermy3.jpg"></p>
<blockquote>
<ol>
<li>客户端请求NameNode,表示读取文件。</li>
<li>NameNode响应客户端,将block(数据块)的信息发送给客户端。</li>
<li>客户端检查数据块信息,连接相关的DataNode。</li>
<li>DataNodeA将block1发送给客户端。</li>
<li>DataNodeB将block2发送给客户端。</li>
<li>拼接数据,读取完成。</li>
</ol>
</blockquote>
<h3 id="HDFSShell命令"><a href="#HDFSShell命令" class="headerlink" title="HDFSShell命令"></a>HDFSShell命令</h3><table>
<thead>
<tr>
<th>命令名</th>
<th>格式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-ls</td>
<td>-ls&lt;路径&gt;</td>
<td>查看指定路径的当前目录结构</td>
</tr>
<tr>
<td>-lsr</td>
<td>-lsr&lt;路径&gt;</td>
<td>递归查看指定路径的目录结构</td>
</tr>
<tr>
<td>-du</td>
<td>-du&lt;路径&gt;</td>
<td>统计目录下个文件大小</td>
</tr>
<tr>
<td>-dus</td>
<td>-dus&lt;路径&gt;</td>
<td>汇总统计目录下文件(夹)大小</td>
</tr>
<tr>
<td>-count</td>
<td>-count[-q]&lt;路径&gt;</td>
<td>统计文件(夹)数量</td>
</tr>
<tr>
<td>-mv</td>
<td>-mv&lt;源路径&gt;&lt;目的路径&gt;</td>
<td>移动</td>
</tr>
<tr>
<td>-cp</td>
<td>-cp&lt;源路径&gt;&lt;目的路径&gt;</td>
<td>复制</td>
</tr>
<tr>
<td>-rm</td>
<td>-rm[-skipTrash]&lt;路径&gt;</td>
<td>删除文件/空白文件夹</td>
</tr>
<tr>
<td>-rmr</td>
<td>-rmr[-skipTrash]&lt;路径&gt;</td>
<td>递归删除</td>
</tr>
<tr>
<td>-put</td>
<td>-put&lt;多个 linux 上的文件&gt;</td>
<td>上传文件</td>
</tr>
<tr>
<td>-copyFromLocal</td>
<td>-copyFromLocal&lt;多个 linux 上的文件&gt;</td>
<td>从本地复制</td>
</tr>
<tr>
<td>-moveFromLocal</td>
<td>-moveFromLocal&lt;多个 linux 上的文件&gt;</td>
<td>从本地移动</td>
</tr>
<tr>
<td>-getmerge</td>
<td>-getmerge&lt;源路径&gt;</td>
<td>合并到本地</td>
</tr>
<tr>
<td>-cat</td>
<td>-cat</td>
<td>查看文件内容</td>
</tr>
<tr>
<td>-text</td>
<td>-text</td>
<td>查看文件内容</td>
</tr>
<tr>
<td>-copyToLocal</td>
<td>-copyToLocal[-ignoreCrc][-crc][hdfs 源路 径][linux 目的路径]</td>
<td>复制到本地</td>
</tr>
<tr>
<td>-moveToLocal</td>
<td>-moveToLocal[-crc]</td>
<td>移动到本地</td>
</tr>
<tr>
<td>-mkdir</td>
<td>-mkdir</td>
<td>创建空白文件夹</td>
</tr>
<tr>
<td>-setrep</td>
<td>-setrep[-R][-w]&lt;副本数&gt;&lt;路径&gt;</td>
<td>修改副本数量</td>
</tr>
<tr>
<td>-touchz</td>
<td>-touchz&lt;文件路径&gt;</td>
<td>创建空白文件</td>
</tr>
<tr>
<td>-stat</td>
<td>-stat[format]&lt;路径&gt;</td>
<td>显示文件统计信息</td>
</tr>
<tr>
<td>-tail</td>
<td>-tail[-f]&lt;文件&gt;</td>
<td>查看文件尾部信息</td>
</tr>
<tr>
<td>-chmod</td>
<td>-chmod[-R]&lt;权限模式&gt;[路径]</td>
<td>修改权限</td>
</tr>
<tr>
<td>-chown</td>
<td>-chown[-R][属主][:[属组]] 路径</td>
<td>修改属主</td>
</tr>
<tr>
<td>-chgrp</td>
<td>-chgrp[-R] 属组名称 路径</td>
<td>修改属组</td>
</tr>
<tr>
<td>-help</td>
<td>-help[命令选项]</td>
<td>帮助</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://www.usherblog.site/2018/01/24/%E5%A4%A7%E6%95%B0%E6%8D%AE02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Usher">
      <meta itemprop="description" content="Honor To The End">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Usher_Ou's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/24/%E5%A4%A7%E6%95%B0%E6%8D%AE02/" class="post-title-link" itemprop="url">CAP与BASE</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">نُشر في</span>

      <time title="أُنشأ: 2018-01-24 03:56:29" itemprop="dateCreated datePublished" datetime="2018-01-24T03:56:29+08:00">2018-01-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">عُدل في</span>
        <time title="عُدل: 2018-01-23 19:56:58" itemprop="dateModified" datetime="2018-01-23T19:56:58+08:00">2018-01-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">في</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="CAP与BASE"><a href="#CAP与BASE" class="headerlink" title="CAP与BASE"></a>CAP与BASE</h1><h2 id="CAP原则"><a href="#CAP原则" class="headerlink" title="CAP原则"></a>CAP原则</h2><blockquote>
<p>CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。CAP原则是NOSQL数据库的基石。Consistency（一致性）。 Availability（可用性）。Partition tolerance（分区容错性）。分布式系统的CAP理论：理论首先把分布式系统中的三个特性进行了如下归纳：一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）分区容忍性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</p>
</blockquote>
<h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><blockquote>
<p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。接下来我们着重对BASE中的三要素进行详细讲解。</p>
<h4 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h4><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用，以下两个就是“基本可用”的典型例子。</p>
<ul>
<li>响应时间上的损失：正常情况下，一个在线搜索引擎需要0.5秒内返回给用户相应的查询结果，但由于出现异常（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。</li>
<li>功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</li>
</ul>
<p>弱状态也称为软状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据听不的过程存在延时。</p>
<h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性</p>
<p>总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，和传统事务的ACID特性使相反的，它完全不同于ACID的强一致性模型，而是提出通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性与BASE理论往往又会结合在一起使用。</p>
</blockquote>
<h2 id="数据分割"><a href="#数据分割" class="headerlink" title="数据分割"></a>数据分割</h2><blockquote>
<p>数据分割是指把逻辑上是统一整体的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE/5947370">数据</a>分割成较小的、可以独立管理的物理单元进行存储，以便于<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%87%8D%E6%9E%84/2182519">重构</a>、重组和恢复，以提高创建<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95/5716853">索引</a>和顺序扫描的效率。数据分割使<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93">数据仓库</a>的开发人员和使用者具有更大的灵活性</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>对当前细节数据进行分割的总体目的就是把数据划分成小的物理单元，为操作者和设计者在管理数据时提供更大的灵活性。小物理单元具有容易重构、自由索引、顺序扫描、容易重组、容易恢复和容易监控等优点。数据仓库的本质之一就是灵活地访问数据，大块数据达不到这个目的。</p>
<h3 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h3><p>数据分割的标准可以根据实际情况来确定，通常可选择按日期、地域、业务领域或组织单位等来进行分割，也可以按多个分割标准的组合来进行，但一般情况下，分割标准应包括日期项。</p>
<p>例如，数据分割的标准是由开发人员选择的，在数据仓库中按日期总是必需的。</p>
<h3 id="层次"><a href="#层次" class="headerlink" title="层次"></a>层次</h3><p>分割的层次一般分为系统层和应用层。系统层的分割由数据库管理系统和操作系统完成；应用层的分割由应用系统完成，在应用层上的分割更有意义。</p>
<h3 id="分割方法"><a href="#分割方法" class="headerlink" title="分割方法"></a>分割方法</h3><h3 id="水平分割"><a href="#水平分割" class="headerlink" title="水平分割"></a>水平分割</h3><p>水平分割(Horizontal Splitting)就是把全局关系的元组分割成一些子集，这些子集被称为数据分片或段(Fragment)。数据分片中的数据可能是由于某种共同的性质(如地理、归属)而需要聚集一起的。通常，一个关系中的数据分片是互不相交的，这些分片可以选择地放在一个站点上，也可以通过副本被重复放在不同的站点上。</p>
<h3 id="垂直分割"><a href="#垂直分割" class="headerlink" title="垂直分割"></a>垂直分割</h3><p>垂直分割(Vertical Splitting)就是把全局关系按着属性组(纵向)分割成一些数据分片或段(Fragment)。数据分片中的数据可能是由于使用上的方便或访问的共同性而需要聚集一起的。通常，一个关系中的垂直数据分片问只在某些键值上重叠，其他属性是互不相交的。这些垂直分片可以放一个站点上，也可以通过副本被重复放在不同的站点上</p>
</blockquote>
<h2 id="副本策略"><a href="#副本策略" class="headerlink" title="副本策略"></a>副本策略</h2><blockquote>
<p><strong>Primary-secondary协议</strong></p>
<p>  该协议是中心化副本控制协议中常常用到的，该协议将副本分为两类：其中仅有一个副本作为primary副本，其他副本都作为secondary副本。维护primary副本的节点作为中心节点，中心节点负责维护数据的更新、并发控制、协同副本的一致性。</p>
<p>​                                      <img src="https://images2017.cnblogs.com/blog/1323418/201801/1323418-20180123180345178-1454325569.png" alt="img"></p>
<p><strong>（1）数据更新的基本流程：</strong></p>
<p>1.数据更新都有Primary节点协调完成。</p>
<p>2.外部节点将更新操作发给Primary节点。</p>
<p>3.Primary节点进行并发控制即确定并发更新操作的先后顺序。</p>
<p>4.Primary节点将更新操作发送给secondary节点</p>
<p>5.primary根据secondary节点的完成情况决定更新是否成功并将结果返回外部节点</p>
<p><strong>（2）数据读取方式</strong></p>
<p>与数据更新流程类似，读取方式也与一致性高度相关。使用primary-secondary比较困难的是实现强一致性。实现强一致性一般有如下几个思路：</p>
<p>1.始终只读primary副本的数据</p>
<p>2.由primary控制节点secondary节点的可用性。</p>
<p>3.基于Quorum机制</p>
<p><strong>（3）Primary副本的确定和切换</strong></p>
<p>primary副本的确定通常由原信息管理，由专门的元数据服务器维护，执行更新操作时，首先查询元数据服务器获取副本的primary信息，从而进一步执行数据更新流程。 primary副本的切换通常可以使用lease机制来完成。</p>
<p><strong>（4）数据同步</strong></p>
<p>数据同步是因为primary副本可能会存在于secondary副本不一致的问题。通常有如下三种形式：</p>
<p>1.由于网络分化等异常，secondary上的数据落后于primary上的数据。—— redo primary副本上的操作日志。</p>
<p>2.在某些协议下，secondary上的数据有可能是脏数据，需要被丢弃。—— undo日志的方法删除脏数据</p>
<p>3.secondary是一个新增加的副本，完全没有数据，需要从其他副本上拷贝数据。—— 使用primary副本的snapshot（快照）功能</p>
<p><strong>paxos协议</strong></p>
<p>多个节点直接通过操作日志同步数据，如果只有一个节点称为主节点，就很容易在多个节点之间维护数据一致性。然后主节点可能出现故障，那么就需要选出主节点。Paxos协议就是用于解决多个节点之间的一致性问题</p>
<p>在paxos算法中，分为4种角色：  </p>
<p>Proposer ：提议者  </p>
<p>Acceptor：决策者  </p>
<p>Client：产生议题者  </p>
<p>Learner：最终决策学习者</p>
<p>4种角色中，提议者和决策者是很重要的，其他的2个角色在整个算法中较弱 Proposer就像Client的使者，由Proposer使者拿着Client的议题去向Acceptor提议，让Acceptor来决策。</p>
<p><strong>最终决策的paxos算法行为:</strong></p>
<p>1.Proposer提出议题</p>
<p>2.Acceptor初步接受或者Acceptor初步不接受</p>
<p>3.如果上一步Acceptor初步接受则Proposer再次向Acceptor确认是否最终接受</p>
<p>4.Acceptor最终接受或者Acceptor最终不接受</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="الصفحة السابقة"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="الصفحة التالية"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Usher</span>
</div>
  <div class="powered-by">تطبيق الموقع <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
